<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"   
	"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
<!ENTITY author "<ulink url='mailto:johnson.AT.worldhello.net'>Johnson</ulink>">
<!ENTITY orgname "<ulink url='http://www.worldhello.net'>worldhello.net</ulink>">
<!ENTITY appendix1 SYSTEM "appendix1.xml">
<!ENTITY appendix2 SYSTEM "appendix2.xml">
<!ENTITY % vers   SYSTEM "version.xml">
%vers;
]>
<article id="index">
<articleinfo>
<title>软件配置管理 HOWTO</title>
<subtitle>VSS, Starteam, CVS, or Others?</subtitle>
<author><firstname>鑫</firstname><surname>蒋</surname></author>
<affiliation>
<orgname>&orgname;</orgname>
<address><email>johnson.AT.worldhello.net</email></address>
</affiliation>

<abstract>
<para>
<ulink url="http://www.worldhello.net/">本网站</ulink>还可以提供 版本控制系统（CVS）等的用户培训 以及 CVS 服务器配置 等收费服务，咨询电话参见 <ulink url="http://www.worldhello.net/">本网站联系方式</ulink>。
</para>
<para>
（编译自版本: &doc.revision;，最后更新时间: &doc.lastchange;）
</para>
</abstract>

<revhistory>
<!--revision>
<revnumber>$Revision: 1.60 $</revnumber>
<date>$Date: 2005/02/24 09:20:52 $</date>
<authorinitials>$Author: jiangxin $</authorinitials>
<revremark>...</revremark>
</revision-->

<revision>
<revnumber>2.4</revnumber>
<date>2005/02/24</date>
<authorinitials>jiangxin</authorinitials>
<revremark>
<link linkend="linux-acl">补充 acl 对CVS进行精确的权限控制</link>；
</revremark>
</revision>
<revision>
<revnumber>2.3</revnumber>
<date>2003/11/17</date>
<authorinitials>jiangxin</authorinitials>
<revremark>
<link linkend="rm-cvs-tmpfiles">定期清理CVSROOT脚本产生的临时文件</link>；
</revremark>
</revision>
<revision>
<revnumber>2.2</revnumber>
<date>2003/8/15</date>
<authorinitials>jiangxin</authorinitials>
<revremark>
<link linkend="bug-spaceinfilename">修正了当目录或者文件名中包含空格，CVSROOT脚本工作不正常，不能发送邮件的 BUG</link>；
</revremark>
</revision>
<revision>
<revnumber>2.1</revnumber>
<date>2003/4/9</date>
<authorinitials>jiangxin</authorinitials>
<revremark>
增加<link linkend="starteam2cvs">版本管理系统的迁移</link>。
</revremark>
</revision>
<revision>
<revnumber>2.0</revnumber>
<date>2003/2/19</date>
<authorinitials>jiangxin</authorinitials>
<revremark>
增加<link linkend="cvs-admin-files">用CVS管理文件进行功能扩充</link>。
</revremark>
</revision>
<revision>
<revnumber>1.9</revnumber>
<date>2003/1/21</date>
<authorinitials>jiangxin</authorinitials>
<revremark>
由于1.11.2版的CVS存在着的服务器端 <link linkend="cvsbug-softlink">repository soft-link 的BUG</link>，因此重新规划服务器端存储，增加了<link linkend="cvs-account">CVS目录目录权限设置</link>。
</revremark>
</revision>
<revision>
<revnumber>1.8</revnumber>
<date>2002/11/19</date>
<authorinitials>jiangxin</authorinitials>
<revremark>
<link linkend="cvs-faq">增加CVS使用FAQ。</link>
</revremark>
</revision>
<revision>
<revnumber>1.7</revnumber>
<date>2002/09/10</date>
<authorinitials>jiangxin</authorinitials>
<revremark>
<link linkend="cvs-modshare">增加通过 modules 文件，建立模块实现目录共享</link>
</revremark>
</revision>
<revision>
<revnumber>1.6</revnumber>
<date>2002/09/08</date>
<authorinitials>jiangxin</authorinitials>
<revremark>
<link linkend="vs-cmd">增加 Starteam, CVS 命令对照</link>
</revremark>
</revision>
<revision>
<revnumber>1.5</revnumber>
<date>2002/08/02</date>
<authorinitials>jiangxin</authorinitials>
<revremark>
补充 Starteam 和 Microsoft Visual C++ 的集成
</revremark>
</revision>
<revision>
<revnumber>1.4</revnumber>
<date>2002/05/27</date>
<authorinitials>jiangxin</authorinitials>
<revremark>
补充命令行参考，并修订其它章节
</revremark>
</revision>
<revision>
<revnumber>1.3</revnumber>
<date>2002/03/04</date>
<authorinitials>jiangxin</authorinitials>
<revremark>
<link linkend="workstation">客户端设置</link>
</revremark>
</revision>
<revision>
<revnumber>1.2</revnumber>
<date>2002/03/01</date>
<authorinitials>jiangxin</authorinitials>
<revremark>
修改FAQ，更具可读性。如：<link linkend="faq-status-unknown">
关于status Unknown 的FAQ</link>
</revremark>
</revision>
<revision>
<revnumber>1.1</revnumber>
<date>2002/01/10</date>
<authorinitials>jiangxin</authorinitials>
<revremark>转换为Docbook格式</revremark>
</revision>
<revision>
<revnumber>1.0</revnumber>
<date>2001/12</date>
<authorinitials>jiangxin</authorinitials>
<revremark>增加FAQ，修改删除反删除</revremark>
</revision>
<revision>
<revnumber>0.9</revnumber>
<date>2001/11/23</date>
<authorinitials>jiangxin</authorinitials>
<revremark>CWAP组Starteam使用经验报告</revremark>
</revision>
</revhistory>

</articleinfo>

<sect1 id="tocvsfun"><title>Overview</title>
<!--
对于软件开发，工作量的估算常常用人月作为单位。在二十年前的一本软件开发经典《人月神话》就已谈到，这会导致一个认识上的错误，人为人、月可以互换，通过投入足够多的人手，可以相应比例的缩短工期。这个认识上的错误，今天仍在软件开发行业普遍存在。问题源自于项目的沟通，随着开发人月的膨胀，沟通成本大大增加。
</para>
<para>
配置管理就是协助开发小组完善沟通管理的有利工具，即便它不是解决软件危机的制胜法宝。代码的版本控制将追踪代码的每一次改动，并能够有效的管理
缺陷管理、变更管理。
</para>
一个小项目不可能需要一个SCM组或变更控制小组……但配置管理和过程控制是必需的。

如果缺乏创新性，软件设计就会是沉闷而刻板的；如果缺少规则，则软件设计将是混乱不堪的。


只有将优秀工作人员的经验教训纳入文档化的过程，并且通过培训，使更多的其他工作人员具备执行那些过程所必须掌握的技能，由此，这个成功的软件过程才得以不断地重复和不断地改造……（CMMPOST.44）


低成熟度的机构把有才干的职员看作是挽救混乱项目的最佳选择，而成熟的机构把有才干的职员看作是把文化和方法转移到新应用领域的最佳选择。


管理的九大知识领域中，

1. The CM plan: this is the actual plan that will be implemented to address the CM needs. It gives all the procedures, policies, schedules, responsibilities, etc. as discussed in Appendix on the OUTLINE OF A MODEL CM PLAN. 
2. The CM system: this is the tool(s) chosen to assist in automating parts of the CM process. 
3. The CM adoption strategy: this is the strategy used to assist the organization in adopting the CM process and the CM system and institutionalizing such. 

－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－

	PVCS works on single files like RCS and SCCS, CVS works on
	complete subsystems.  PVCS has a make utility (called a
	configuration builder), CVS does not.  PVCS has a GUI interface
	for Unix, DOS, OS/2, and MS Windows.

－－－－－－－－－－－－－－－－－－－－－－－－－
	CVS uses RCS to do much of its work and absolutely all the work
	of changing the underlying RCS files in the Repository.


	RCS comprises a set of programs designed to keep track of changes
	to individual files.  Of course, it also allows you to refer to
	multiple files on the command line, but they are handled by
	iterating over individual files.  There is no pretense of
	coordinated interaction among groups of files.


	CVS's main intent is to provide a set of grouping functions that
	allow you to treat a collection of RCS files as a single object.
	Of course, CVS also has to do a lot of iteration, but it tries
	its best to hide that it is doing so.  In addition, CVS has some
	truly group-oriented facets, such as the modules file and the CVS
	administrative files that refer to a whole directory or module.


	One group aspect that can be a bit confusing is that a CVS branch
	is not the same as an RCS branch.  To support a CVS branch, CVS
	uses "tags" (what RCS calls "symbols") and some local state,
	in addition to RCS branches.


	Other features offered by CVS that are not supported directly by
	RCS are


Automatic determination of the state of a file, (e.g.
		modified, up-to-date with the Repository, already tagged
		with the same string, etc.)  which helps in limiting the
		amount of displayed text you have to wade through to
		figure out what changed and what to do next.


A copy-modify-merge scheme that avoids locking the files
		and allows simultaneous development on a single file.


Serialization of commits.  CVS requires you to merge all
		changes committed (via "update") since you checked out
		your working copy of the file.	Although it is still
		possible to commit a file filled with old data, it is less
		likely than when using raw RCS.


Relatively easy merging of releases from external Vendors.


－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
	SCCS is much closer to RCS than to CVS, so some of the previous
	entry applies.


	You might want to take a look at Walter Tichy's papers on RCS,
	which are referred to in the RCS man pages.


－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
	ClearCase is a distributed client-server version control system.
	ClearCase is a variant DSEE tools, formerly available on Apollo
	platforms.  The ClearCase tool set includes a few X-based
	interface tools, a command-line interface, and C programmer API.
	It is currently available on Sun, HP, SGI and OSF/1 platforms.


	ClearCase uses a special Unix filesystem type, called "mvfs"
	for "multi-version file system".  Conceptually, mvfs adds
	another dimension to a regular Unix filesystem.	 The new
	axis is used to store the different versions of files and to
	provide a tree-hierarchical view of a collection of objects that
	might be scattered across any number of separate hosts on your
	local network.


	Each user acquires a "view" into the file database by creating a
	special mvfs mount point on their machine.  Each view has a
	"configuration spec" containing a set of selection rules that
	specify the particular version of each file to make visible in
	that view.  You can think of a "view" as a work area in CVS, except
	that the files don't really exist on your local disk until you
	modify them.  This technique conserves disk space because it
	doesn't keep private copies of read-only files.


	Another advantage is that a view is "transparent" in the sense that
	all of the files in a "view" appear to be regular Unix files to
	other tools and Unix system calls.  An extended naming convention
	allows access to particular versions of a file directly:
	"test.cc@@/main/bugfix/3" identifies the third version of test.c
	on the bugfix branch.


	ClearCase supports both the copy-modify-merge model of CVS (by
	using what are called "unreserved checkouts" and the
	checkin/checkout development model with file locking.  Directories
	are version-controlled objects as well as files.  A graphical merge
	tool is provided.  Like RCS, ClearCase supports branches, symbolic
	tags, and delta compression.  ASCII as well as binary files are
	supported, and converters from RCS, SCCS, DSEE formats are also
	included.


	A make-compatible build facility is provided that can identify
	common object code and share it among developers.  A build
	auditing feature automatically records file dependencies by
	tracking every file that is opened when producing a derived
	object, thus making explicit dependency lists unnecessary.  Pre-
	and post-event triggers are available for most ClearCase
	operations to invoke user programs or shell scripts.  User-defined
	attributes can be assigned to any version or object.  Hyper-links
	between version controlled objects can record their relationship.


	For more information, contact:


	  Atria Software, Inc.
	  24 Prime Park Way
	  Natick, MA 01760
	  info@atria.com

－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－


The goals of using CM are to ensure the integrity of a product and to make its evolution more manageable. Although there is overhead involved in using CM, it is generally agreed that the consequences of not using CM can lead to many problems and inefficiencies. The overhead of using CM relates to time, resources, and the effects on other aspects of the software lifecycle", Susan Dart, CMI. 


From ClearCase, voted the worlds #1 CM tool, right through to CVS - popular and free. Other CM/SCM products like PVCS, eChangeMan, Continuus, and many more are now available to Uniface developers around the world. 


Many organizations use Microsoft’s Visual SourceSafe to protect code and to version
development files. Visual SourceSafe has the advantage of being bundled with Microsoft
development tools, and it is a great way to begin imposing basic versioning, immediately.

Visual SourceSafe is a free tool that is bundled with Microsoft’s Visual Studio.

Visual SourceSafe is not scalable, robust enough nor full featured to meet these more
complex, enterprise strength needs.



PVCS products can co-exist with Visual SourceSafe, so
there is no need to choose between one or the other — smaller teams or dedicated
Visual Studio teams can continue to use Visual SourceSafe.


You may not have paid out any money, but you have paid in terms of
lost productivity, rework and developer frustration.



M o r e o v e r, code reuse

and efficient parallel development

-->

<para>
CVS 是开放源码的一个奇迹，亦是开放源码得以延续和发展的推动者，是版本控制的经典。CVS 是常用的版本控制工具。
</para>
<para>
Starteam 是一个集合了版本控制和缺陷控制两种功能的软件，并且具有 CVS 没有的强大的图形界面，易学易用。2002年底被Borland公司收购，发展前景未知，它是我是用的第一个大型商用版本控制软件（真的付了Money的呦）。
</para>
<tip>
<para>
评价 CVS、STARTEAM 孰优孰劣，是一个仁者见仁，智者见智的问题。
</para>
<para>
Starteam 的图形化界面，能够使初学者易于接收，而且其缺陷控制功能的功能（基于数据库的Change Request），是CVS 不具有的，更是相应工具中独树一帜的。
</para>
<para>
CVS的优秀跨平台能力、强大的命令行、清晰的服务器端数据结构更便于数据的备份、灾难恢复和可靠性。Simple is Butiful 送给 CVS 一定没错。
</para>
</tip>
<orderedlist>
<listitem>
<para>
侧重不同
</para>
<para>
CVS专注于配置管理软件范畴中的版本管理系统。而配置管理系统除了包括版本管理外，还包括构建管理（Build Management）和缺陷跟踪系统。而Starteam包括了这三项。本文档也就只比较其版本管理系统的异同。
</para>
</listitem>
<listitem>
<para>
权限控制
</para>
<para>
一般来说，CVS的权限设置单一，通常只能通过CVSROOT/passwd, CVSROOT/readers, CVSROOT/writers 文件，同时还要设置CVS REPOS的物理目录权限来完成权限设置，无法完成复杂的权限控制；而STARTEAM无需通过物理路径的权限设置，而是通过自己的数据库管理，实现了类似WINDOWS NT的域用户管理和目录文件ACL控制。
</para>
<para>
但是CVS通过CVSROOT目录下的脚本，提供了相应功能扩充的接口，不但可以完成精细的权限控制，还能完成更加个性化的功能。
</para>
</listitem>
<listitem>
<para>
易用性
</para>
<para>
Starteam的图形界面功能强大，但其命令行功能较CVS弱，需要自己编写shell脚本加强。而随着WINCVS作为图形客户端的可用性的增强，Starteam的强项正在被削弱。
</para>
</listitem>
<listitem>
<para>
Label的管理
</para>
<para>
CVS 的 label 建立在文件上，难以确定到底有多少存在的 label ，而STARTEAM（图形界面）可以很方便知道有哪些 View Label及Revision Label。
</para>
<para>
CVS的版本分支， label是建立在文件上，工作在其他分支的程序同样会看到其它分支的label；而Starteam的label只在同一个视图内有效，有独立的命名空间。
</para>
<para>
STARTEAM具有Promotion states，可以看作是label的标签。在label上又封装一层的 Promotion State 便于记录版本的提升，和建立自动编译；而CVS 没有浮动 label 的概念，只能通过文件记录方式实现（如我们使用 .promotion 文件记录当前稳定的 label）。
</para>
</listitem>
<listitem>
<para>
文件缓存
</para>
<para>
Starteam 存在CACHE目录，缓存了所有 Checkout的版本的文件，因此 Checkout速度快。而CVS没有缓存，check out过程较慢，尤其是分支的 Checkout。
</para>
<note>
<para>
但我对此表示怀疑。尤其是Starteam Unix客户端基于JAVA技术，速度明显比CVS要慢。
</para>
</note>
</listitem>
<listitem>
<para>
操作文件名和目录名
</para>
<para>
CVS的REPOSITORY的物理存储结构即为项目的组织结构，使得文件名修改和目录的重新组织成为难题，往往需要管理员权限去手动操作Repository；而STARTEAM的Repository的文件结构和视图的文件结构可以完全不同，目录、文件名修改和移动非常方便，基于数据库的文件名管理还可以方便地在不同工程之间共享文件，协同工作。
</para>
</listitem>
<listitem>
<para>
CVS是程序员的工具，STARTEAM还是管理项目的工具
</para>
<para>
个人文件管理或小项目的组织，需要轻量级的管理，和灵活的文件导入、导出，以及和自由代码的交互，则CVS，Perforce，PVCS，SourceSafe等面向文件的版本控制占优势。对于公司、大项目，需要独立的测试、QA等分工，还要更多的考虑多样的用户权限控制，易用性（图形界面），缺陷控制，则需要面向工程的STARTEAM来进行版本控制和开发。
</para>
</listitem>
<listitem>
<para>
CVS的优势
</para>
<para>
CVS的优势：项目文件可以方便的组合和移植，这是因为CVS以文件为核心，即面向文件的管理方式。而且目前网络上很多开放源码都采用CVS，可以很好沟通。
</para>
<para>
CVS配置简单、健壮、可以很容易地移植；STARTEAM集成度较高，移植过程复杂，需要的管理负担大，需要完善的备份计划。
</para>
<para>
CVS是开发源码，服务器端存储易于理解，便于控制；而Starteam为商业软件，服务器端存储方式封闭，难以管理。但是 CVS 不提供图形界面，有较长的学习曲线。
</para>
</listitem>
<listitem>
<para>
Starteam 的劣势
</para>
<para>
不支持分支的合并，需要过多的手动干预。而CVS可以自动完成。
</para>
<para>
速度慢，一定程度上影响开发效率。
</para>
<para>
不支持并行开发，不能很好解决Merge的问题。而CVS可以智能 Merge。
</para>
<para>
故障恢复困难，需要有专职管理员维护。而CVS易于维护。
</para>
</listitem>
<listitem>
<para>
评价优劣，不如先用先得
</para>
<para>
不用刻意去取舍哪一个，只要用好，即可。况且，已经有了完美的CVS、STARTEAM互相转换的方法。（参见：《CVS, Starteam互相转换》）
</para>
</listitem>
</orderedlist>
<para>
下面通过对 CVS、STARTEAM 的服务器端和客户端对照，了解背后的真相。
</para>

</sect1>


<sect1 id="vs-svrsetup"><title>CVS vs. STARTEAM——服务器设置</title>

<sect2><title>CVS服务器设置</title>
<sect3><title>运行 CVS</title>

<itemizedlist>
<listitem>
<para>
<filename>/etc/services</filename>
</para>
<screen>
...
cvspserver      2401/tcp
cvspserver      2401/udp
...
</screen>
</listitem>

<listitem>
<para>
用xinetd运行: <filename>/etc/xinetd.d/cvs</filename>
</para>
<screen>
<![CDATA[
service cvspserver
{
        socket_type     = stream        
        protocol        = tcp
        wait            = no
        user            = root
        server          = /usr/bin/cvs
        server_args     = -f --allow-root=/repos/root1 --allow-root=/repos/root2 pserver
        disable         = no
}
]]>
</screen>
</listitem>

<listitem>
<para>
用inetd运行: <filename>/etc/inetd.conf</filename>
</para>
<screen>
<![CDATA[
...
cvspserver stream tcp nowait root /usr/bin/cvs cvs -f --allow-root=/repos/project --allow-root=/repos/user pserver
...
]]>
</screen>
</listitem>

</itemizedlist>

</sect3>

<sect3 id="cvs-account"><title>添加帐号和设置权限</title>

<itemizedlist>

<listitem>
<para>
创建系统帐号
</para>
<para>
假设目录 <filename>/repos/project</filename> 作为多人共享项目的版本控制根目录，需要用组权限控制；<filename>/repos/user</filename>作为存放个人独占地版本控制根目录。管理员帐号为cvsroot，项目版本控制的公共帐号为 cvsproject，用户版本控制的公共帐号为 cvsuser，相应的用户组为 cvsroot, cvsproject, cvsuser。
</para>
<screen>
$ groupadd cvsproject
$ groupadd cvsuser
$ groupadd cvsroot
$ useradd  -g cvsproject -s /sbin/nologin         cvsproject
$ useradd  -g cvsuser    -s /sbin/nologin         cvsuser
$ useradd  -g cvsroot    -G cvsproject,cvsuser    cvsroot               <co id="co.cvs.multigroup"/>
$ useradd  -g cvsuser    -s /sbin/nologin         cvs_jiangxin          <co id="co.cvs.user"/>
$ useradd  -g cvsuser    -s /sbin/nologin         cvs_johnson           
</screen>
<calloutlist>
<callout arearefs="co.cvs.multigroup">
<para>
设置 cvsroot 属于多个组，这样 cvsroot 用户除了进行系统维护外（如添加新的工程），还可以和其它组用户一样具有管理代码的权限。
</para>
</callout>
<callout arearefs="co.cvs.user">
<para>
用来和CVS用户帐号一一对应的系统帐号。系统帐号禁止登录，密码设置在相应的 CVS 对应帐号文件中设置。
</para>
</callout>
</calloutlist>

</listitem>

<listitem>
<para>
创建CVS根目录
</para>
<screen>
<![CDATA[
$ mkdir -p /repos/project
$ mkdir -p /repos/user
$ chown cvsroot:cvsroot /repos/project
$ chown cvsroot:cvsroot /repos/user
$ chmod  775 /repos
$ chmod 2775 /repos/project
$ chmod 2775 /repos/user
$ su - cvsroot
$ cvs -d /repos/project init
$ cvs -d /repos/user init
]]>
</screen>

<para>
运行完毕 <command>cvs init</command> 之后，在CVS根目录下创建了配置目录<filename>CVSROOT</filename>，权限如下：
</para>

<screen>
$ ls -l /repos/project/CVSROOT/

-r--r--r--    1 cvsroot  cvsroot       493 Jan 21 10:37 checkoutlist
-r--r--r--    1 cvsroot  cvsroot       696 Jan 21 10:37 checkoutlist,v
-r--r--r--    1 cvsroot  cvsroot       760 Jan 21 10:37 commitinfo
-r--r--r--    1 cvsroot  cvsroot       963 Jan 21 10:37 commitinfo,v
-r--r--r--    1 cvsroot  cvsroot       527 Jan 21 10:37 config
-r--r--r--    1 cvsroot  cvsroot       730 Jan 21 10:37 config,v
-r--r--r--    1 cvsroot  cvsroot       753 Jan 21 10:37 cvswrappers
-r--r--r--    1 cvsroot  cvsroot       956 Jan 21 10:37 cvswrappers,v
-r--r--r--    1 cvsroot  cvsroot      1025 Jan 21 10:37 editinfo
-r--r--r--    1 cvsroot  cvsroot      1228 Jan 21 10:37 editinfo,v
drwxrwxr-x    2 cvsroot  cvsroot      4096 Jan 21 10:37 Emptydir
-rw-rw-rw-    1 cvsroot  cvsroot         0 Jan 21 10:37 history
-r--r--r--    1 cvsroot  cvsroot      1141 Jan 21 10:37 loginfo
-r--r--r--    1 cvsroot  cvsroot      1344 Jan 21 10:37 loginfo,v
-r--r--r--    1 cvsroot  cvsroot      1151 Jan 21 10:37 modules
-r--r--r--    1 cvsroot  cvsroot      1354 Jan 21 10:37 modules,v
-r--r--r--    1 cvsroot  cvsroot       564 Jan 21 10:37 notify
-r--r--r--    1 cvsroot  cvsroot       767 Jan 21 10:37 notify,v
-r--r--r--    1 cvsroot  cvsroot       649 Jan 21 10:37 rcsinfo
-r--r--r--    1 cvsroot  cvsroot       852 Jan 21 10:37 rcsinfo,v
-r--r--r--    1 cvsroot  cvsroot       879 Jan 21 10:37 taginfo
-r--r--r--    1 cvsroot  cvsroot      1082 Jan 21 10:37 taginfo,v
-rw-rw-rw-    1 cvsroot  cvsroot         0 Jan 21 10:37 val-tags
-r--r--r--    1 cvsroot  cvsroot      1026 Jan 21 10:37 verifymsg
-r--r--r--    1 cvsroot  cvsroot      1229 Jan 21 10:37 verifymsg,v
</screen>
<para>
可以看出文件 history, val-tags 的权限是任何人可读写，其它文件的权限是任何帐号只读。
</para>
<para>
文件 <filename>CVSROOT/val-tags</filename> 用来确定是否一个TAG是可用的；文件 <filename>CVSROOT/history</filename> 用来记录CVS的访问记录。
</para>
</listitem>
<listitem>
<para>
创建 CVS 用户帐号
</para>
<para>
使用系统帐号不安全，而CVS提供了独立于系统的用户帐号管理。
</para>
<para>
使用配置文件 <filename>CVSROOT/passwd</filename>, <filename>CVSROOT/passwd</filename>, <filename>CVSROOT/passwd</filename> ，来管理帐号。
</para>
<screen>
$ cat /repos/project/CVSROOT/passwd
jiangxinroot:_passwd_here_:cvsroot	<co id="co.cvspasswd.root"/>
jiangxin:_passwd_here_:cvsproject
johnson:_passwd_here_:cvsproject	<co id="co.cvspasswd.project"/>
anonymous::cvsproject			<co id="co.cvspasswd.anonymous"/>

$ cat /repos/project/CVSROOT/readers
anonymous				<co id="co.cvsreaders.anonymous"/>

</screen>

<calloutlist>
<callout arearefs="co.cvspasswd.root">
<para>
用户帐号 jiangxinroot，具有和系统帐号 cvsroot 同样权限。
</para>
</callout>
<callout arearefs="co.cvspasswd.project">
<para>
用户帐号 jiangxin, johnson，都具有系统帐号 cvsproject 同样的权限，
</para>
</callout>
<callout arearefs="co.cvspasswd.anonymous">
<para>
匿名帐号 anonymous 的密码为空。
</para>
</callout>
<callout arearefs="co.cvsreaders.anonymous">
<para>
readers 文件中出现的用户帐号，只具有只读权限。
</para>
</callout>
</calloutlist>

</listitem>
<listitem>
<para>
CVS 用户修改口令
</para>
<para>
我写了一个程序，作为用户登录的 shell，允许用户远程 SSH 登录，修改自己的 Unix 系统口令以及 CVS 账号口令，参见：<link linkend="faq-cvspasswd">附件</link>。如果您有更好的方法，不吝赐教。
</para>
</listitem>

</itemizedlist>
</sect3>

<sect3><title>创建工程</title>

<para>
只能以 cvsroot 用户创建工程。因为 cvs 根目录的权限设置为 cvsroot 帐户可写。
</para>

<itemizedlist>
<listitem>
<para>
在客户端创建工程
</para>
<screen>
client$ cvs -d :pserver:jiangxinroot@10.0.0.7:/repos/project login
client$ cvs -d :pserver:jiangxinroot@10.0.0.7:/repos/project import -m "add module test, vendor jiangxin, init_tag start." test jiangxin start

$ ls -l /repos/project
drwxrwxr-x    3 cvsroot  cvsroot      4096 Jan 21 10:54 CVSROOT
drwxrwsr-x    2 cvsroot  cvsroot      4096 Jan 21 11:00 test	 <co id="co.priv.test"/>

$ chown -R cvsproject:cvsproject test
$ chmod -R 770 test		
$ chmod -R g+s test		<co id="co.priv.setgid"/>

client$ cvs -d :pserver:jiangxin@10.0.0.7:/repos/project co test		<co id="co.priv.checkout"/>
client$ cvs -d :pserver:johnson@10.0.0.7:/repos/project  co -d test2 test
</screen>
<calloutlist>
<callout arearefs="co.priv.test">
<para>
设置工程/模块 test 的目录权限，使只有 cvsproject组用户才有读写权限，其他帐号拒绝访问。
</para>
</callout>
<callout arearefs="co.priv.checkout">
<para>
用户帐号 jiangxin, johnson 映射为系统帐号 cvsproject，因此可以访问工程 test。
</para>
</callout>
<callout arearefs="co.priv.setgid">
<para>
之所以为模块 test 设置 g+s，是为了当设置一个用户属于多个时，操作不同工程时，能够保障文件的组id维持不变。否则可能影响其它用户的权限。可以用更简单的命令执行 <command>chmod -R 2770 test</command> 进行设置。
</para>
</callout>
</calloutlist>
<para>
于是创建了多用户共享的工程 test。
</para>
</listitem>

<listitem>
<para>
另一种创建工程的方法：在服务器端创建工程
</para>
<para>
可以直接在服务器端创建目录，设置权限，即完成工程的创建。当然这样创建的工程只是一个空的工程，需要在客户端为空的工程逐个添加文件和目录。
</para>
<screen>
$ cat /repos/project/CVSROOT/passwd
jiangxroot:_passwd_here_:cvsroot
anonymous:_passwd_here_:cvsuser
jiangxin:_passwd_here_:cvs_jiangxin
johnson:_passwd_here_:cvs_johnson

$ cd /repos/project
$ mkdir jiangxin; chown -R cvs_jiangxin:cvsuser jiangxin; chmod -R 2700 jiangxin
$ mkdir johnson;  chown -R cvs_johnson:cvsuser  johnson;  chmod -R 2700 johnson
</screen>
<para>
于是创建了两个用户独占的工程。
</para>

</listitem>
</itemizedlist>
</sect3>

<sect3 id="cvs-admin-files"><title>用CVS管理文件进行功能扩充</title>
<para>
确省安装的CVS的权限仅仅作用于目录，而不能精细到文件级别。而且即使用户只需要拥有文件的只读权限，也要对相应的目录具有写权限，因为需要在目录下创建锁定文件。有一个办法可以避免此问题，即：通过配置文件 <filename><ulink url="CVSROOT/config">CVSROOT/config</ulink></filename> 的 LockDir 来设置单独的锁定目录，为该单独的锁定目录设置更宽泛的权限控制。
</para>
<para>
CVS 提供了功能的扩充接口：CVSROOT目录下的管理文件。这些文件提供了相应功能扩充的接口，不但可以完成精细的权限控制，还能完成更加个性化的功能。关于CVSROOT下的脚本，FreeBSD 的源代码就有一个非常好的CVSROOT脚本，可供我们参照：
</para>
<para>
<ulink url="http://www.freebsd.org/doc/en_US.ISO8859-1/articles/cvs-freebsd/article.html">Setting up a CVS repository - the FreeBSD way</ulink>。我们可以参照这个指南，定制我们自己的CVSROOT脚本。
</para>
<para>
下载 FreeBSD 的 CVSROOT 脚本，可以以匿名用户连接到 FreeBSD 的 CVS 服务器：
</para>
<screen>
$ cvs -d :pserver:anoncvs@anoncvs.freebsd.org:2401/home/ncvs login   # 输入密码 anoncvs
$ cvs -d :pserver:anoncvs@anoncvs.freebsd.org:2401/home/ncvs co  CVSROOT-src
</screen>
<para>
下载获得 FreeBSD 的 CVSROOT 代码后，需要进行相应的定制，然后才能 checkin 到自己的 CVSROOT 目录中。这个补丁是我对其的修改和定制：<ulink url="CVSROOT/patch.txt">patch.txt</ulink>。
</para>
<para>
定制过程：
</para>
<orderedlist>
<listitem>
<para>
升级CVS
</para>
<para>
确认安装的CVS服务器版本，要高于 1.11.2 。因为我们要用到在版本 1.11.2 才出现的功能：能够在检查commit log 后重新读入 commit log，以实现对 commit log 的格式化。
</para>
</listitem>

<listitem>
<para>
定制 PERL 模块 cfg.pm
</para>
<para>
文件 <filename><ulink url="CVSROOT/cfg.pm">CVSROOT/cfg.pm</ulink></filename>，是 perl脚本的核心包，对其做了一些改动，主要是添加了禁止某些用户发送 Email功能；还增加了部分子过程，部分是从原 log_acum.pl 中移动过来，目的将这些函数设置为模块内部的函数便于其它需要发送邮件的脚本调用，如脚本 log_accum.pl 和 tagcheck 都需要使用这些新增子过程。
</para>
<para>
对脚本 <filename><ulink url="CVSROOT/cfg.pm">CVSROOT/cfg.pm</ulink></filename> 的改动如下：
</para>
<screen>
diff -u -r1.1 -r1.2
--- cfg.pm	14 Aug 2003 10:00:53 -0000	1.1
+++ cfg.pm	15 Aug 2003 01:44:20 -0000	1.2
@@ -17,9 +17,10 @@
 	$ADD_TO_LINE $AVAIL_FILE $CHECK_HEADERS $COMMITCHECK_EXTRA
 	@COMMIT_HOSTS $COMMITTER $DEBUG $DIFF_BLOCK_TOTAL_LINES $EXCLUDE_FILE
 	$FILE_PREFIX $IDHEADER $LAST_FILE @LOG_FILE_MAP $MAILADDRS $MAILBANNER
-	$MAILCMD $MAIL_BRANCH_HDR $MAIL_ON_DIR_CREATION $MAIL_TRANSFORM
+	$MAILCMD $MAIL_BRANCH_HDR @MAIL_MAP $MAIL_ON_DIR_CREATION $MAIL_TRANSFORM
 	$MINCVSVERSION $MAX_DIFF_SIZE $NO_DOS_LINEBREAKS $PID $PROG_CVS
 	$PROG_MV %TEMPLATE_HEADERS $TMPDIR $UNEXPAND_RCSID $WARN_HEADERS
+	$BADSENDER_FILE
 );
 
 my $CVSROOT = $ENV{'CVSROOT'} || die "Can't determine \$CVSROOT!";
@@ -52,7 +53,7 @@
 $PROG_MV =	'/bin/mv';		# mv(1)
 
 # The username of the committer.
-$COMMITTER = $ENV{"LOGNAME"} || $ENV{'USER'} || getlogin
+$COMMITTER = <emphasis>$ENV{"CVS_USER"} </emphasis>|| $ENV{"LOGNAME"} || $ENV{'USER'} || getlogin   <co id="co.cvs.get.committer"/>
		|| (getpwuid($&lt;))[0] || sprintf("uid#%d",$&lt;);
 
 
@@ -83,6 +84,7 @@
 # commit to what.
 $AVAIL_FILE = "$CVSROOT/CVSROOT/avail";
 
+$BADSENDER_FILE = "$CVSROOT/CVSROOT/blocksender"; <co id="co.cvs.blocksender"/>
 
 ################
 ### logcheck ###
@@ -208,6 +210,10 @@
 	'other'		=&gt; '.*'
 );
 
+@MAIL_MAP = (
+	'nobody'	=&gt; '.*'
+);
+
 # Include diffs of not greater than this size in kbytes in the
 # commit mail for each file modified. (0 = off).
 $MAX_DIFF_SIZE = 0;
@@ -270,6 +276,64 @@
 	return @output;
 };
 
+
+############################################################
+#
+# Subroutines
+#
+############################################################
+
+# !!! Mailing-list and commitlog history file mappings here !!!
+# This needs pulling out as a configuration block somewhere so
+# that others can easily change it.
+
+sub get_log_name {
+	my $dir = shift;	# Directory name
+
+
+	for my $i (0 .. ($#cfg::LOG_FILE_MAP - 1) / 2) {
+		my $log = $cfg::LOG_FILE_MAP[$i * 2];
+		my $pattern = $cfg::LOG_FILE_MAP[$i * 2 + 1];
+
+		return $log if $dir =~ /$pattern/;
+	}
+
+	return 'other';
+}
+
+sub get_mail_name {
+	my $dir = shift;	# Directory name
+	my $CVSROOT = $ENV{'CVSROOT'};
+	$dir =~ s,^$CVSROOT[/]?,,g;
+	$dir .= "/" unless $dir =~ /\/$/;
+	
+	for my $i (0 .. ($#cfg::MAIL_MAP - 1) / 2) {
+		my $email = $cfg::MAIL_MAP[$i * 2];
+		my $pattern = $cfg::MAIL_MAP[$i * 2 + 1];
+		return $email if $dir =~ /$pattern/;
+	}
+
+	return $cfg::MAILADDRS;
+}
+
+
+# do not send email, if committer is in badsender file...
+sub sendmail_acl_check {
+	my $sendmail = 1;
+	if (-e $cfg::BADSENDER_FILE)
+	{
+		open (BADSENDER, $cfg::BADSENDER_FILE) || die "open $cfg::BADSENDER_FILE: $!\n";
+		while (&lt;BADSENDER&gt;) {
+			if ($_ =~ /\b$cfg::COMMITTER\b/i)
+			{
+				$sendmail = 0;
+				last;
+			}
+		}
+	}
+	
+	return $sendmail;
+}
 
 ######################################################################
 # Load the local configuration file, that allows the entries in this

</screen>
<calloutlist>
<callout arearefs="co.cvs.get.committer">
<para>
增加检查环境变量 CVS_USER。以能够正确反映使用 CVSROOT/password 文件进行身份验证的用户名。
</para>
</callout>
<callout arearefs="co.cvs.blocksender">
<para>
通过文件 $BADSENDER_FILE 设置哪些用户对 CVS 操作不必发送邮件，这个功能可以用于自动编译下的特定用户的CVS操作不必发送邮件。
</para>
</callout>
</calloutlist>
<note>
<para>
还在该perl模块中增加了几个过程，供其它程序调用。
</para>
</note>

<para>
文件 <filename><ulink url="CVSROOT/cfg_local.pm">CVSROOT/cfg_local.pm</ulink></filename> 用于对模块 cfg.pm 进行定制：
</para>
<screen>
hash$ <command>diff -u -r1.1 cfg_local.pm</command>
--- cfg_local.pm	14 Aug 2003 10:00:53 -0000	1.1
+++ cfg_local.pm	15 Aug 2003 03:09:39 -0000	1.3
@@ -13,7 +13,7 @@
 ####################################################################
 ####################################################################
 
-$CHECK_HEADERS = 1;
+$CHECK_HEADERS = 0; <co id="co.cvs.nocheckheader"/>
 $IDHEADER = 'FreeBSD';
 $UNEXPAND_RCSID = 1;
 
@@ -29,25 +29,30 @@
 $MAILCMD = "/usr/local/bin/mailsend -H";
 $MAIL_BRANCH_HDR  = "X-FreeBSD-CVS-Branch";
 $ADD_TO_LINE = 0;
-$MAILBANNER = "FreeBSD src repository";
+$MAILBANNER = "My repository"; <co id="co.cvs.mailbanner"/>
 if (defined $ENV{'CVS_COMMIT_ATTRIB'}) {
   my $attrib = $ENV{'CVS_COMMIT_ATTRIB'};
   $MAILBANNER .= " ($attrib committer)";
 }
+# The minimum version of cvs that we will work with.
+$MINCVSVERSION = "1110200";  # 1.11.2 <co id="co.cvs.mincvsversion"/>
+
+$MAIL_ON_DIR_CREATION = 0; <co id="co.cvs.mailoncreation"/>
 
 # Sanity check to make sure we've been run through the wrapper and are
 # now primary group 'ncvs'.
 #
-$COMMITCHECK_EXTRA = sub {
-	my $GRP=`/usr/bin/id -gn`;
-	chomp $GRP;
-	unless ( $GRP =~ /^ncvs$/ ) {
-		print "You do not have group ncvs (commitcheck)!\n";
-		exit 1;	# We could return false here.  But there's
-			# nothing to stop us taking action here instead.
-	}
-	return 1;
-};
+
+#$COMMITCHECK_EXTRA = sub { <co id="co.cvs.nocheckgrp"/>
+#	my $GRP=`/usr/bin/id -gn`;
+#	chomp $GRP;
+#	unless ( $GRP =~ /^ncvs$/ ) {
+#		print "You do not have group ncvs (commitcheck)!\n";
+#		exit 1;	# We could return false here.  But there's
+#			# nothing to stop us taking action here instead.
+#	}
+#	return 1;
+#};
 
 # Wrap this in a hostname check to prevent mail to the FreeBSD
 # list if someone borrows this file and forgets to change it.
@@ -91,6 +96,22 @@
@LOG_FILE_MAP = ( <co id="co.cvs.local.filemap"/>
	'CVSROOT'	=&gt; '^CVSROOT/',
	'distrib'	=&gt; '^distrib/',
	'doc'		=&gt; '^doc/',
	'ports'		=&gt; '^ports/',
	'www'		=&gt; '^www/',

 	'other'		=> '.*'
 );
+# CVSROOT is still shared between src, ports, doc at the moment. projects has
+# its own CVSROOT.
+@MAIL_MAP = ( <co id="co.cvs.local.mailmap"/>
+	'maillist1' => '^CVSROOT/',
+	'maillist2' => '^src/',
+	'cvsnone' => '.*',
+); 
+
+@TAG_MAP = ( <co id="co.cvs.local.tagmap"/>
+	'jiangxin' => '^(release|mailstome).*',
+); 
+
+# Email addresses of recipients of commit mail.
+$MAILADDRS = 'cvsnone'; <co id="co.cvs.local.mailaddrs"/>
+
+
 
 1; # Perl requires all modules to return true.  Don't delete!!!!
 #end
</screen>
<calloutlist>
<callout arearefs="co.cvs.nocheckheader">
<para>
设置为0，不强制文件头包含特定的CVS关键字。
</para>
</callout>
<callout arearefs="co.cvs.mincvsversion">
<para>
设置安装的CVS服务器的最低版本为 1.11.2；
</para>
</callout>
<callout arearefs="co.cvs.mailoncreation">
<para>
创建目录的事件，也发送邮件。参见脚本：<filename><ulink url="CVSROOT/log_accum.txt">CVSROOT/log_accum.pl</ulink></filename>。
</para>
</callout>
<callout arearefs="co.cvs.nocheckgrp">
<para>
注释该函数，不检查用户组。
</para>
</callout>
<callout arearefs="co.cvs.local.filemap">
<para>
定制该数组，将 CVS 模块的 commit log 存储在对应的文件中。
</para>
</callout>
<callout arearefs="co.cvs.local.mailmap">
<para>
添加哈希表 @MAIL_MAP，设置模块和用户邮件地址的对应关系，相应模块的 commit，通过邮件通知相应用户。
</para>
</callout>
<callout arearefs="co.cvs.local.tagmap">
<para>
添加哈希表 @TAG_MAP，设置某些格式的TAG只能被某些用户管理。
</para>
</callout>
<callout arearefs="co.cvs.local.mailaddrs">
<para>
确省的邮件地址。对于没有在 MAIL_MAP 数组找到匹配的邮件地址，即使用该地址。确省为 'nobody'。
</para>
</callout>
</calloutlist>
</listitem>

<listitem>
<para>
CVS 服务器配置文件：<filename><ulink url="CVSROOT/config">CVSROOT/config</ulink></filename>
</para>
<screen>
#SystemAuth=no                 <co id="co.cvs.config.sysauth"/>
#LockDir=/var/lock/cvs         <co id="co.cvs.config.lockdir"/>
#TopLevelAdmin=no
LogHistory=TOFEWGCMAR          <co id="co.cvs.config.logall"/>
RereadLogAfterVerify=always    <co id="co.cvs.config.reloadlog"/>
</screen>
<calloutlist>
<callout arearefs="co.cvs.config.sysauth">
<para>
如果设置 SystemAuth=no，则只通过 CVS 提供的身份验证。
</para>
</callout>
<callout arearefs="co.cvs.config.lockdir">
<para>
可以用来指定单独的锁定目录， 便可以更灵活的设置数据仓库的目录权限。
</para>
</callout>
<callout arearefs="co.cvs.config.logall">
<para>
对所有事件记录日志，亦可写为 LogHistory=all。
</para>
</callout>
<callout arearefs="co.cvs.config.reloadlog">
<para>
启用只有在 1.11.2 版本才具有的 commit log 重写功能。
</para>
</callout>
</calloutlist>
</listitem>

<listitem>
<para>
文件 <filename><ulink url="CVSROOT/cvsignore">CVSROOT/cvsignore</ulink></filename>
</para>
<para>
设置版本控制过程中，需要忽略的文件。这些文件将不被显示为未知状态（"?"）。如：
</para>
<screen>
*.db
*.info
*.[Sp]o
*.core
*.aps
*.clw
*.exe
*.ncb
*.obj
*.opt
*.plg
Debug
Release
</screen>
<note>
<para>
亦可由每个目录下的文件 <filename>.cvsignore</filename> 来控制；
</para>
<para>
对于 WinCVS，则由文件 <filename>C:\.cvsignore</filename> 来控制，如果将 HOME 路径设置为 C:\ 的话。
</para>
</note>
</listitem>

<listitem>
<para>
文件 <filename><ulink url="CVSROOT/cvswrappers">CVSROOT/cvswrappers</ulink></filename>
</para>
<para>
匹配文件名，并作相应处理。如： -kb 即以二进制方式处理文件。
</para>
<screen>
*.gif -k 'b'
*.GIF -k 'b'
*.jpg -k 'b'
...
</screen>
</listitem>

<listitem>
<para>
文件 <filename><ulink url="CVSROOT/modules">CVSROOT/modules</ulink></filename>
</para>
<para>
设置数据仓库中的模块名，可以通过命令：“cvs co -c”察看当前数据仓库（repository）中包含的模块/工程名称。也可以在调整服务器端目录结构时，设置 modules 来保持和以前设置的兼容性。
</para>
<screen>
CVSROOT	CVSROOT
module1	module2 &amp;module3
</screen>
</listitem>

<listitem>
<para>
文件 <filename><ulink url="CVSROOT/checkoutlist">CVSROOT/checkoutlist</ulink></filename>
</para>
<para>
列在 checkoutlist 中的文件，在 checkin 后，能够自动在服务器 CVSROOT 目录中重建。
</para>
<screen>
#access             <co id="co.cvs.checkoutlist"/>
avail
cfg.pm
cfg_local.pm
commit_prep.pl
commitcheck
cvs_acls.pl
exclude
log_accum.pl
logcheck
options
rcstemplate
tagcheck
unwrap
wrap
</screen>
<calloutlist>
<callout arearefs="co.cvs.checkoutlist">
<para>
access 文件供 FreeBSD 的cvs wrapper程序调用，进行权限控制，如不需要该功能注释掉，忽略该文件。
</para>
</callout>
</calloutlist>
</listitem>

<listitem>
<para>
文件 <filename><ulink url="CVSROOT/notify">CVSROOT/notify</ulink></filename>
</para>
<para>
当用户设置了 watch 一个文件，可以定制该文件进行控制。在此该文件未被用到。
</para>
</listitem>

<listitem>
<para>
文件 <filename><ulink url="CVSROOT/commitinfo">CVSROOT/commitinfo</ulink></filename>
</para>
<para>
Commit 事件要触发三个脚本文件，依次是 commitinfo, verifymsg, loginfo。其中先遍历整个目录树对所有需要 commit 的文件执行 commitinfo文件。再分别针对每一个目录执行 verifymsg, loginfo 脚本。
</para>
<para>
commitinfo 会调用 commitcheck 脚本，完成的功能：通过用户主机名、用户名来检查权限；确认CVS服务器的版本号不低于某个版本；将遍历目录树的结果（最后一个目录名）记录下来，以便接下来运行 verifymsg, loginfo的脚本能够确认运行结束等。
</para>
<para>
相关文件：<filename><ulink url="CVSROOT/commitcheck">CVSROOT/commitcheck</ulink></filename>，<filename><ulink url="CVSROOT/cvs_acls.txt">CVSROOT/cvs_acls.pl</ulink></filename>，<filename><ulink url="CVSROOT/avail">CVSROOT/avail</ulink></filename>，<filename><ulink url="CVSROOT/commit_prep.txt">CVSROOT/commit_prep.pl</ulink></filename>，<filename><ulink url="CVSROOT/exclude">CVSROOT/exclude</ulink></filename>，<filename><ulink url="CVSROOT/cfg.pm">CVSROOT/cfg.pm</ulink></filename>，<filename><ulink url="CVSROOT/cfg_local.pm">CVSROOT/cfg_local.pm</ulink></filename>。
</para>
<para>
文件 <filename><ulink url="CVSROOT/avail">CVSROOT/avail</ulink></filename>，被脚本 cvs_acls.pl 读取，再被脚本 commitcheck 调用，用以精细控制权限。例如：
</para>
<screen>
<![CDATA[
group|meisters|peter,jdp,markm,joe
# Pick up the list of bad users from ncvs/CVSROOT/badcommitters  See that
# file for details
group|penaltybox|!badcommitters

unavail
avail||CVSROOT
avail||distrib
avail||doc
avail||ports
avail||src
unavail||src/contrib/binutils,src/contrib/file
avail|obrien|src/contrib/binutils,src/contrib/file
unavail||src/contrib/tcpdump
avail|fenner,nectar|src/contrib/tcpdump
avail||www
avail|:meisters
unavail|:penaltybox
]]>
</screen>
</listitem>

<listitem>
<para>
文件 <filename><ulink url="CVSROOT/verifymsg">CVSROOT/verifymsg</ulink></filename>
</para>
<para>
用于检查和格式化 commit log。禁止在版本控制提交时，使用空的 commit log。对于 wincvs 在用户不提交 commit log 时，会自动使用“no message”作为commit log。为了禁止该情况发生，需要定制该脚本：
</para>
<para>
相关文件：<filename><ulink url="CVSROOT/logcheck">CVSROOT/logcheck</ulink></filename>。
</para>
<screen>
bash$ <command>diff -u -r1.1 logcheck</command>
--- logcheck	14 Aug 2003 10:00:53 -0000	1.1
+++ logcheck	15 Aug 2003 02:01:37 -0000	1.2
@@ -47,8 +47,10 @@
 
 # Remove leading and trailing blank lines.  (There will be at most
 # one because of the duplicate removal above).
+local $^W = 0;                        <co id="co.cvs.hide.err"/>
 shift @log_in if $log_in[0] eq "";
 pop @log_in if $log_in[-1] eq "";
+local $^W = 1;
 
 # Scan through the commit message looking for templated headers
 # as defined in the configuration file, and rcstemplate.
@@ -104,6 +106,9 @@
 # completely empty.  This is a bug in cvs.
 my $log = "@log_in";
 die "Log message contains no content!\n" if $log =~ /^\s*$/;
+
+# commit without commit log using WINCVS , will automatically provide commit log as "no message".
+die "Log message contains no content using WINCVS!\n" if $log =~ /^no message$/ or $log =~ /^\.+$/; <co id="co.cvs.logcheck.wincvs"/>
</screen>
<calloutlist>
<callout arearefs="co.cvs.hide.err">
<para>
隐藏语法警告；
</para>
</callout>
<callout arearefs="co.cvs.logcheck.wincvs">
<para>
禁止其它的无意义的commit log，其中一个是 WINCVS 缺省的 COMMITLOG，一个是本人以前随意的COMMITLOG风格。
</para>
</callout>
</calloutlist>
</listitem>

<listitem>
<para>
文件 <filename><ulink url="CVSROOT/loginfo">CVSROOT/loginfo</ulink></filename>
</para>
<para>
将 commit log 分门别类存储在目录 CVSROOT/commitlogs 下，并同时通过邮件外发。为了防止一次事件触发多次的邮件外发，该脚本利用到 commitinfo 的运行结果，只有确认到了目录树的最后，才发送邮件。 模块和存储日志文件以及用户邮件列表在文件<filename><ulink url="CVSROOT/cfg_local.pm">CVSROOT/cfg_local.pm</ulink></filename>中定义。
</para>
<para>
相关文件：<filename><ulink url="CVSROOT/log_accum.txt">CVSROOT/log_accum.pl</ulink></filename>，<filename><ulink url="CVSROOT/cfg.pm">CVSROOT/cfg.pm </ulink></filename>，<filename><ulink url="CVSROOT/cfg_local.pm">CVSROOT/cfg_local.pm</ulink></filename>。
</para>
<para>
文件 <filename><ulink url="CVSROOT/loginfo">CVSROOT/loginfo</ulink></filename>，调用脚本 log_accum.pl，并传递文件名等参数，用于组织日志和发送邮件。
</para>
<para>
<anchor id="bug-spaceinfilename"/>
原 FreeBSD 脚本存在一个 BUG，如果文件名或者目录名中存在空格，脚本运行不正常，出错，导致不能组织和发送邮件，这个 Bug 修正方法如下：
</para>
<para>
在文件 <filename><ulink url="CVSROOT/loginfo">CVSROOT/loginfo</ulink></filename>中调用 log_accum.pl 时使用的参数由原来的 %s 修改为 %{,,,s}，即加入三个连续的逗号作为分隔符，否则使用空格作为分隔符，难以区分是文件的分隔符还是路径或文件名中的空格。
</para>
<screen>
bash$ tail -1 loginfo
DEFAULT         $CVSROOT/CVSROOT/log_accum.pl %{,,,s}
</screen>
<para>
对文件 <filename><ulink url="CVSROOT/log_accum.txt">CVSROOT/log_accum.pl</ulink></filename> 的修正如下：
</para>
<screen>
bash$ diff -u -r1.1 log_accum.pl

--- log_accum.pl	14 Aug 2003 10:00:53 -0000	1.1
+++ log_accum.pl	15 Aug 2003 02:00:35 -0000	1.2
@@ -47,6 +47,7 @@
 my $LOG_FILE      = "$BASE_FN.log";
 my $SUMMARY_FILE  = "$BASE_FN.summary";
 my $LOGNAMES_FILE = "$BASE_FN.lognames";
+my $MAILNAMES_FILE = "$BASE_FN.mailnames"; <co id="co.cvsroot.logac.mailnames_file"/>
 my $SUBJ_FILE     = "$BASE_FN.subj";
 my $TAGS_FILE     = "$BASE_FN.tags";
 my $DIFF_FILE     = "$BASE_FN.diff";
@@ -233,7 +234,8 @@
 	while (&lt;RCS&gt;) {
 		if (/^[ \t]*Repository revision/) {
 			chomp;
-			my @revline = split;
+			my @revline = split(/[ \t]+/, $_, 5); <co id="co.cvsroot.logac.revline"/>
+			shift @revline while($revline[0] eq "");
 			$revision = $revline[2];
 			$revline[3] =~ m|^$CVSROOT/+(.*),v$|;
 			$rcsfile = $1;
@@ -383,20 +385,6 @@
 # !!! Mailing-list and commitlog history file mappings here !!!
 # This needs pulling out as a configuration block somewhere so
 # that others can easily change it.
-sub get_log_name { <co id="co.cvsroot.logac.movetopm"/>
-	my $dir = shift;	# Directory name
-
-
-	for my $i (0 .. ($#cfg::LOG_FILE_MAP - 1) / 2) {
-		my $log = $cfg::LOG_FILE_MAP[$i * 2];
-		my $pattern = $cfg::LOG_FILE_MAP[$i * 2 + 1];
-
-		return $log if $dir =~ /$pattern/;
-	}
-
-	return 'other';
-}
-
 
 sub do_changes_file {
 	my @text = @_;
@@ -408,11 +396,17 @@
 		$unique{$category} = 1;
 
 		my $changes = "$CVSROOT/CVSROOT/commitlogs/$category";
-		open CHANGES, "&gt;&gt;$changes"
-			or die "Cannot open $changes.\n";
-		print CHANGES map { "$_\n" } @text;
-		print CHANGES "\n\n\n";
-		close CHANGES;
+		if (open CHANGES, "&gt;&gt;$changes")
+		{
+			print CHANGES map { "$_\n" } @text;
+			print CHANGES "\n\n\n";
+			close CHANGES;
+		}
+		else <co id="co.cvsroot.logac.notdie"/>
+		{
+			print "Cannot open $changes.\n";
+		}
+
 	}
 }
 
@@ -420,22 +414,29 @@
 sub mail_notification {
 	my @text = @_;
 
-# This is turned off since the To: lines go overboard.
-# Also it has bit-rotted since, and can't just be switched on again.
-# - but keep it for the time being in case we do something like cvs-stable
-#	my @mailaddrs = &amp;read_logfile($LOGNAMES_FILE);
-#	print(MAIL 'To: cvs-committers' . $dom . ", cvs-all" . $dom);
-#	foreach $line (@mailaddrs) {
-#		next if ($unique{$line});
-#		$unique{$line} = 1;
-#		next if /^cvs-/;
-#		print(MAIL ", " . $line . $dom);
-#	}
-#	print(MAIL "\n");
+	if (! &amp;cfg::sendmail_acl_check()) <co id="co.cvsroot.logac.mailto"/>
+	{
+		print "mail sent from $cfg::COMMITTER is blocked.\n";
+		return 0;	
+	}
+
+	my %unique = ();
+	my @mailaddrs = &amp;read_logfile($MAILNAMES_FILE);
+	# ok, this is kinda hokey, but I need to break up lines with multiple addresses
+	my $fu = join(" ", @mailaddrs);
+	@mailaddrs = split " ", $fu;
+
+	my $to = "";
+	foreach my $category (@mailaddrs) {
+		next if ($unique{$category});
+		$unique{$category} = 1;
+
+		$to .= " " unless $to eq "";
+		$to .= $category;
+	}
 
 	my @email = ();
 
-	my $to = $cfg::MAILADDRS;
 	print "Mailing the commit message to '$to'.\n";
 
 	push @email, "To: $to" if $cfg::ADD_TO_LINE;
@@ -497,10 +498,14 @@
 	}
 
 	# Send the email.
-	open MAIL, "| $cfg::MAILCMD $to"
-	    or die "Please check $cfg::MAILCMD.";
-	print MAIL map { "$_\n" } @email;
-	close MAIL;
+	if(fork() == 0)
+	{
+		open MAIL, "| $cfg::MAILCMD -F $cfg::COMMITTER $to" <co id="co.cvsroot.logac.mailcmd"/>
+	    		or die "Please check $cfg::MAILCMD.";
+		print MAIL map { "$_\n" } @email;
+		close MAIL;
+	}
+	exit(0);
 }
 
 
@@ -634,8 +639,9 @@
 #
 # Initialize basic variables
 #
+my $separator=",,,"; <co id="co.cvsroot.logac.separator"/>
 my $input_params = $ARGV[0];
-my ($directory, @filenames) = split " ", $input_params;
+my ($directory, @filenames) = split / ${separator}/, $input_params; <co id="co.cvsroot.logac.getfilename"/>
 #@files = split(' ', $input_params);
 
 my @path = split('/', $directory);
@@ -660,8 +666,9 @@
 }
 
 # Was used for To: lines, still used for commitlogs naming.
-&amp;append_line($LOGNAMES_FILE, &amp;get_log_name("$directory/"));
-&amp;append_line($SUBJ_FILE, "$directory " . join(" ", sort @filenames));
+&amp;append_line($LOGNAMES_FILE, &amp;cfg::get_log_name("$directory/")); <co id="co.cvsroot.logac.get.logname"/>
+&amp;append_line($MAILNAMES_FILE, &amp;cfg::get_mail_name("$directory/")); <co id="co.cvsroot.logac.get.mailname"/>
+&amp;append_line($SUBJ_FILE, "$directory/(" . join(",", sort @filenames) .") "); <co id="co.cvsroot.logac.get.subjname"/>
 
 #
 # Check for a new directory first.  This will always appear as a
@@ -697,7 +704,7 @@
 
 	&amp;do_changes_file(@text);
 	&amp;mail_notification(@text);
-	system("/usr/local/bin/awake", $directory);
+	# system("/usr/local/bin/awake", $directory);
 	&amp;cleanup_tmpfiles();
 	exit 0;
 }
@@ -742,7 +749,28 @@
 	}
 
 	# otherwise collect information about which files changed.
-	my @files = split;
+	my @tmpfiles = split;
+	my $strname = "";
+	my @files;
+	while (my $item = shift(@tmpfiles))
+	{
+		if ($strname eq "") 
+		{
+			$strname = $item;
+		} 
+		else	
+		{
+			$strname .= " $item";
+		} 
+		for (my $i=0; $i&lt;=$#filenames; $i++)
+		{
+			if ($strname eq $filenames[$i])
+			{
+				push (@files, $strname);
+				$strname = "";
+			}
+		}
+	}
 	push @{ $changed_files{$tag} },	@files if $state == $STATE_CHANGED;
 	push @{ $added_files{$tag} },	@files if $state == $STATE_ADDED;
 	push @{ $removed_files{$tag} },	@files if $state == $STATE_REMOVED;
@@ -896,7 +924,7 @@
 	&amp;mail_notification(@log_msg);
 }
 
-system("/usr/local/bin/awake", $directory);
+# system("/usr/local/bin/awake", $directory);
 &amp;cleanup_tmpfiles();
 exit 0;
 # EOF
</screen>

<calloutlist>
<callout arearefs="co.cvsroot.logac.mailnames_file">
<para>
存储邮件地址的临时文件；
</para>
</callout>
<callout arearefs="co.cvsroot.logac.revline">
<para>
避免当文件名中包含空格时，$rcsfile 获取失败；
</para>
</callout>
<callout arearefs="co.cvsroot.logac.movetopm">
<para>
该函数被移动到 cfg.pm 模块，成为模块的子过程；
</para>
</callout>
<callout arearefs="co.cvsroot.logac.notdie">
<para>
没有找到日志记录文件，发出警告，不中断；
</para>
</callout>
<callout arearefs="co.cvsroot.logac.mailto">
<para>
读取哈希表 @MAIL_MAP，获取改动代码需要发送到的邮件地址；
</para>
</callout>
<callout arearefs="co.cvsroot.logac.mailcmd">
<para>
发送邮件，设置发件人为 $cfg::COMMITTER；
</para>
</callout>
<callout arearefs="co.cvsroot.logac.separator">
<para>
字段分隔符，应和 loginfo 文件中指定的向匹配！
</para>
</callout>
<callout arearefs="co.cvsroot.logac.getfilename">
<para>
使用自定义的字段分隔符，以避免由于文件名中出现空格导致文件名获取失败；
</para>
</callout>
<callout arearefs="co.cvsroot.logac.get.logname">
<para>
该函数已经移动到模块 cfg.pm；
</para>
</callout>
<callout arearefs="co.cvsroot.logac.get.mailname">
<para>
设置收件人名单；
</para>
</callout>
<callout arearefs="co.cvsroot.logac.get.subjname">
<para>
设置邮件标题；
</para>
</callout>
</calloutlist>
</listitem>

<listitem>
<para>
文件 <filename><ulink url="CVSROOT/taginfo">CVSROOT/taginfo</ulink></filename>
</para>
<para>
在执行 tag/rtag 命令前执行该脚本，如果脚本返回非零值，tag/rtag 动作取消。
相关脚本：<filename><ulink url="CVSROOT/tagcheck">CVSROOT/tagcheck</ulink></filename>。负责对添加/删除 TAG 事件进行控制——允许/禁止/发送邮件。
</para>
<para>
由于 tag/rtag 事件不象 commit 事件，不是通过多个脚本的配合完成，而是只通过一个脚本 taginfo 完成。这就出现一个问题：如果为一个目录树打上TAG，则可能多次执行脚本，可能要多次触发邮件发送。我的解决办法是，根据TAG进程的 PID 确定在整个过程唯一的文件名，将日志记录到该文件中，taginfo 脚本本身无法知道是否结束，而是系统通过 crontab 定期执行脚本 <ulink url="CVSROOT/checkmailspool.sh">CVSROOT/checkmailspool.sh</ulink>来检查是否有完成的 tag 邮件需要外发。
</para>
<screen>

#!/usr/bin/perl -w
#
# Author: Jiang Xin
# Reference: http://www.worldhello.net/
#

use strict;
use lib $ENV{CVSROOT};
use CVSROOT::cfg;


#############################################################
#
# Main Body
#
# TAG  add/mov/del  repo  files...
# $1   $2           $3    $4   ...
#
############################################################

my $tag = shift;
my $action = shift;
my $repos = shift;
my $fileitem = "";
my $filerev= "";
my $filelist = "";

my $uid = $cfg::COMMITTER;
my $userlist = "";
my $pattern = "";
my $permission = 1;
my $to = "";

my $tmpstr = &amp;cfg::get_mail_name($repos);
$tmpstr =~ s/\@/\./g ;
$tmpstr="nobody" unless $tmpstr;
my $MAILFILE = "/var/spool/cvsmail/cvs.tag.$tmpstr.$cfg::PID"; <co id="co.cvs.tag.filename"/>

die "Usage: tagcheck tag action repos files...\n" unless $repos;

for my $i (0 .. ($#cfg::TAG_MAP - 1) / 2) { <co id="co.cvs.tag.priv"/>
	$userlist = $cfg::TAG_MAP[$i * 2];
	$pattern = $cfg::TAG_MAP[$i * 2 + 1];
	
	if ($tag =~ /$pattern/i)
	{
		if ($userlist =~ /\b$uid\b/i)
		{
			$permission=1;
			last;
		}
		else
		{
			$permission=0;
			last;
		}
	}
}

if ($permission == 0)
{
	# normal users can not do this.
	print STDERR "User \"$cfg::COMMITTER\" canot perform this operation!\n";
	print STDERR "Only users: $userlist, can handle tag patterm: \"$pattern\"!\n";
}

while ($fileitem = shift)
{
        $filerev = shift;
        $filelist = sprintf("%s\t%-24s:\t%s\n", $filelist, $fileitem, $filerev);
}

print "save message in spool `dirname $MAILFILE`...\n";

my @email = ();

if (! -e $MAILFILE )
{
	$to = &amp;cfg::get_mail_name($repos); <co id="co.cvs.tag.mail"/>
	push @email, "From: $uid&lt;$uid&gt;";
	push @email, "To: $to";
	$tmpstr = sprintf("Date: %s", `date -R`);
	chomp $tmpstr;
	push @email, $tmpstr;

	if ($permission == 0)
	{
		push @email, "Subject: cvs tag FAILED! ($action $tag on $repos)";
	}
	else
	{
		push @email, "Subject: cvs tag success: $action $tag on $repos";
	}

	push @email, "";

	delete $ENV{'TZ'};
	$tmpstr = sprintf("%-11s:    %-8s", "Author", $cfg::COMMITTER);
	push @email, $tmpstr;
	$tmpstr = sprintf("%-11s:    %-8s", "Date", `/bin/date +"%Y/%m/%d %H:%M:%S %Z"`);
	chomp $tmpstr;
	push @email, $tmpstr;
	$tmpstr = sprintf("%-11s:    %-8s", "Tag", $tag);
	push @email, $tmpstr;
	$tmpstr = sprintf("%-11s:    %-8s", "Operation", $action);
	push @email, $tmpstr;

	push @email, "";
	push @email, "  $cfg::MAILBANNER", "" if $cfg::MAILBANNER;
}

if ($permission == 0)
{
	push @email, "Permission denied: $action $tag on $repos !";
	push @email, "--------------------------------------------------";
}
else
{
	$tmpstr = sprintf("%-11s:    %-8s", "Repository", $repos);
	push @email, $tmpstr;
	push @email, $filelist if $filelist;
}

#save mail to spool
open MAIL, "&gt;&gt; $MAILFILE "
	or die "Cannot open file $MAILFILE for append.";
print MAIL map { "$_\n" } @email;
close MAIL;

if ($permission == 0)
{
	exit 1
}
else
{
	exit 0
}

</screen>
<calloutlist>
<callout arearefs="co.cvs.tag.filename">
<para>
确定进程唯一的文件名称；
</para>
</callout>
<callout arearefs="co.cvs.tag.priv">
<para>
@cfg::TAG_MAP 数组定义了需要权限控制的 TAG 名称，以及授权人列表。受限的TAG名称对应于软件开发中的里程碑，要严格的权限控制。和该模式匹配的 tag，只能被授权人操作，其它名称的 TAG，所有用户都可以操作。
</para>
</callout>
<callout arearefs="co.cvs.tag.mail">
<para>
邮件地址亦从 MAIL_MAP 数组中获取；
</para>
</callout>
</calloutlist>

<para>
文件 <filename><ulink url="CVSROOT/checkmailspool.sh">CVSROOT/checkmailspool.sh</ulink></filename>，加入到 crontab 中定期执行，检查 tagcheck 生成的邮件。
</para>
<screen>
<![CDATA[
#!/bin/sh
# checkmailspool.sh
# Auther: Jiang Xin
#
# $CVSMAILPATH (cvs mail spool) is a spool directory created by user, 
# and cvs tag message will store in it.
# run this script timely to check cvsmail spool and send messages...
# please put this script in crontab. 


CVSMAILPATH=/var/spool/cvsmail
if [ ! -d $CVSMAILPATH ]; then
	mkdir -p $CVSMAILPATH
	chmod 777 $CVSMAILPATH
fi

cd $CVSMAILPATH
for i in `ls `; do
	pid=`echo $i| sed -e "s/.*\.\([0-9]*\)$/\1/"`
	
	xxx=0
	
	while ps -p $pid>/dev/null; do
		xxx=`expr $xxx + 1`
		if [ $xxx -gt 10 ]; then
			break
		fi
		sleep 3
		echo waiting $pid, $xxx times ...
	done
	echo -e "\n\n========================================" >> $i
	echo -e "End\n" >> $i
	cat $i | sendmail -oi -oem -odb -t
	rm -f $i
done
]]>
</screen>
</listitem>

<listitem id="rm-cvs-tmpfiles">
<para>
清除CVSROOT产生的临时文件
</para>
<para>
以上 CVSROOT 脚步在执行过程中将会在临时目录中产生很多临时文件，如果不加以清理，不但会浪费磁盘空间，更有可能导致发送张冠李戴的错误邮件。在 crontab 中配置每隔一个小时执行一遍以下脚本：
</para>
<screen>
<![CDATA[
#/bin/sh

cd /tmp
ls \#cvs.files.* | sed -e 's/\#cvs.files.\([0-9]*\)\..*$/\1/g' | sort -u | \
while read xxx; do if ps --pid $xxx>/dev/null 2>&1; then continue; fi ; \
    rm -f /tmp/\#cvs.files.$xxx.* ; done
]]>
</screen>

</listitem>

</orderedlist>

</sect3>



<sect3 id="linux-acl"><title>基于 Linux ACL 的权限控制</title>
<para>
Linux ACL 的相关资源参见：
</para>
<itemizedlist>
<listitem>
<para>
Linux ACL Homepage
</para>
<para>
<ulink url="http://acl.bestbits.at/">http://acl.bestbits.at/</ulink>
</para>
</listitem>
<listitem>
<para>
Using ACLs with Fedora Core 2
</para>
<para>
<ulink url="http://www.vanemery.com/Linux/ACL/linux-acl.html">http://www.vanemery.com/Linux/ACL/linux-acl.html</ulink>
</para>
</listitem>
<listitem>
<para>
还有我的一个 Wiki 页面 =)
</para>
<para>
<ulink url="http://jiangxin.worldhello.net/wiki/L/Linux/ACL.htm">http://jiangxin.worldhello.net/wiki/L/Linux/ACL.htm</ulink>
</para>
</listitem>
</itemizedlist>

<para>
为什么要使用 ACL 呢？因为对于一个大的CVS项目，需要对各个模块进行精确的权限控制，如果只靠传统的Unix的目录权限控制 user,group,other 将会大大增进系统管理员的负担，项目的“超级用户”需要同时属于多个用户组，才可以访问所有的模块。
</para>
<para>
突然有一天，发现权限设置不灵了，经过测试，原来 linux 2.4 内核一个用户最多属于 32 个用户组！看来是另辟蹊径的时候了。久闻 acl 的大名，对于2.4内核是以内核补丁方式存在，2.6内核已经集成进去了，这可真是一个好消息。(注意: 2.6.10 内核的ACL存在一个大BUG，已再 2.6.11-rc4 内核中修正。具体参见我的wiki =)
</para>
<para>
虽然使用 acl，对于CVS来说，前面提到的CVS权限控制依然试用。即：
</para>

<itemizedlist>
<listitem>
<para>
项目相关的所有用户必须对CVS工程目录以及工程的CVSROOT目录具有 r-x 权限；</para>
</listitem>
<listitem>
<para>
所有用户对文件 CVSROOT/history, CVSROOT/val-tags, 和目录 CVSROOT/commitlogs/(如果安装了CVSROOT扩展)，必须拥有写权限；
</para>
</listitem>
<listitem>
<para>
设置目录的 setgid 位，使用户创建目录的时候，新目录能够保持上一级目录的用户属主；
</para>
</listitem>
<listitem>
<para>
CVSROOT 下的脚本，需要清除其 setuid, setgid 位，否则脚本执行时报错；
</para>
</listitem>
<listitem>
<para>
为工程添加权限时，不要修改 symbol link 文件权限，以免互相覆盖；
</para>
<para>
例如: 多个项目共享同一个 passwd 文件。执行 setfacl 需要加上 -P 参数；
</para>
</listitem>
</itemizedlist>

<para>
一个权限设置脚本模块：
</para>
<screen>
<![CDATA[
#!/bin/sh
# acl.sh version 0.9

SETFACLCMD="setfacl -P"
CVSHOMEDIR=/cvshome

##############################################################################
#Declare Function:

####################################################################
# /etc/group 记录:
#    tst_root:x:682:u_tst_root
#    tst_doc:x:705:u_tst_doc
#    tst_src:x:683:u_tst_src
#    tst_src_1:x:706:u_tst_src_1
#    tst_src_2:x:707:u_tst_src_2
####################################################################
apply_acl_test()
{
	if [ $# -ne 1 ];then
		echo format: `basename $0` project
		exit 1
	fi
	
	project=$1
	if [ ! -d $project ]; then
		echo "Can not find project: $project."
	fi
		

	# tst_root 组可以访问所有模块，包括 CVSROOT 的写权限
	$SETFACLCMD -d -R -m g:tst_root:rwx  $project
	$SETFACLCMD    -R -m g:tst_root:rwx  $project
	
	# tst_src 组能够访问所有代码、文档
	$SETFACLCMD -d -R -m g:tst_src:rwx   $project/src $project/doc
	$SETFACLCMD    -R -m g:tst_src:rwx   $project/src $project/doc
	
	# 所有用户均能访问文档
	$SETFACLCMD -d -R -m g:tst_src:rwx,g:tst_src_1:rwx,g:tst_src_2:rwx,g:tst_doc:rwx   $project/doc
	$SETFACLCMD    -R -m g:tst_src:rwx,g:tst_src_1:rwx,g:tst_src_2:rwx,g:tst_doc:rwx   $project/doc
	
	
	# 需要权限控制的小组，缺省访问权限
	$SETFACLCMD -d -R -m g:tst_src_1:rwx,g:tst_src_2:rwx   $project/src
	$SETFACLCMD    -R -m g:tst_src_1:rwx,g:tst_src_2:rwx   $project/src
	
	# 设置敏感模块的权限
	$SETFACLCMD -d -R -x g:tst_src_1,g:tst_src_2      $project/src/mod1 $project/src/mod2
	$SETFACLCMD    -R -x g:tst_src_1,g:tst_src_2      $project/src/mod1 $project/src/mod2
	$SETFACLCMD -d -R -m g:tst_src_1:rwx  $project/src/mod1
	$SETFACLCMD    -R -m g:tst_src_1:rwx  $project/src/mod1
	$SETFACLCMD -d -R -m g:tst_src_2:rwx  $project/src/mod2
	$SETFACLCMD    -R -m g:tst_src_2:rwx  $project/src/mod2

	# 需要权限控制的小组，需要能够进入 tst/src 目录，但只有 root,src 组能够在 src 下创建目录。
	# 如此设置，这些用户不能修改 $project/src 目录下面的文件
	#$SETFACLCMD       -m g:tst_src_1:r-x,g:tst_src_2:r-x   $project/src

	# 所有用户组都能够进入（只读访问） tst, tst/CVSROOT 目录，否则无法访问相应模块。但只有 root 组能够在 根 下创建目录和修改 CVSROOT。
	$SETFACLCMD       -m g:tst_src:r-x,g:tst_src_1:r-x,g:tst_src_2:r-x,g:tst_doc:r-x   $project
	$SETFACLCMD    -R -m g:tst_src:r-x,g:tst_src_1:r-x,g:tst_src_2:r-x,g:tst_doc:r-x   $project/CVSROOT
}


apply_acl_other_project()
{
	# ... ...
}

#End Declare Function:
##############################################################################

##############################################################################
# MAIN Function Here
##############################################################################

if [ $# -eq 0 ];then
	echo format: `basename $0` project ...
	exit 1
fi

cd ${CVSHOMEDIR}

while [ $# -gt 0 ]; do
	project=$1
	if [ ! -d $project ]; then
		echo "Can not find project: $project."
		shift
		continue
	fi

	##############################################################################
	# PRE, 预设置
	##############################################################################

	echo -n "Begin PRE ACL Setup for project: $project ..."

	# 设置 ${CVSHOMEDIR}/$project 下文件权限：rwx------, mask 为 rwx；
	# 添加 cvs 超级用户 cvsroot,cvsroot_ro 权限；
	$SETFACLCMD -R -m m::rwx,u::rwx,g::---,o::---,d:m::rwx,d:u::rwx,d:g::---,d:o::---,g:cvsroot:rwx,d:g:cvsroot:rwx,g:cvsroot_ro:r-x,d:g:cvsroot_ro:r-x    ${CVSHOMEDIR}/$project
	
	# 目录属主被子目录集成
	chmod -R g+s           ${CVSHOMEDIR}/$project
	
	# 设置 ${CVSHOMEDIR} 的属主，设置为 nobody.cvsnull，注意最好任何用户不属于 cvsnull；
	chown -R nobody.cvsnull ${CVSHOMEDIR}/$project

	echo "	done"
	
	##############################################################################
	# 开始项目的权限设置
	##############################################################################

	echo -n "Begin ACL Setup for project: $project ..."

	case "$project" in
		test*)
			apply_acl_test  $project
			;;
		*)
			echo "Unknown project name: $project"
			exit 1
			;;
	esac
	
	echo "	done"
	
	##############################################################################
	# POST, 后设置
	##############################################################################

	echo -n "Begin POST ACL Setup for project: $project ..."

	# 将 CVSROOT 目录中的需要完全读写的文件，清除 ACL， 并清除组的粘贴位，
	### 还要注意 symbol link 文件的权限也需要恢复，如文件 passwd, blocksender...
	
	# 因为 CVSROOT 下脚本需要执行，必须去除其 setgid 位
	chmod -R g-s "$project/CVSROOT"

	# 由于去除了用户属主的保持位, 当用户checkin CVSROOT时?其它用户可能访问不到，因此需要设置组能够访问
	# 不能使用 chmod g+rx , 因为对于设置了 ACL， chmod 是修改其 mask
	$SETFACLCMD -R -m m::rwx,u::rwx,g::rwx,o::r-x,d:m::rwx,d:u::rwx,d:g::rwx,d:o::r-x    $project/CVSROOT
	
	# val-tags, history 文件需要所有人的读写权限
	$SETFACLCMD -b "$project/CVSROOT/val-tags" "$project/CVSROOT/history"
	chmod 777 "$project/CVSROOT/val-tags" "$project/CVSROOT/history"

	# commitlogs/ 目录要可写
	$SETFACLCMD -b -R "$project/CVSROOT/commitlogs/"
	chmod -R 777  "$project/CVSROOT/commitlogs/"

	echo "	done"
	
	shift

done

#	$SETFACLCMD -b "/etc/passwd.cvs" "/etc/blocksender"
#	chmod 444 "/etc/passwd.cvs" "/etc/blocksender"

echo ""
echo "Make sure every one has access right"
ls -ld ${CVSHOMEDIR}
ls -l "/etc/passwd.cvs" "/etc/blocksender"
]]>
</screen>


</sect3>

</sect2>

<sect2><title>Starteam服务器权限设置</title>
<para>
每一个服务器配置一个独立的用户数据库设置。用户的权限设置灵活，和本机帐号设置无关（不用设置本地帐号），且和本地路径无关。
</para>


<sect3 id="usermgr"><title>用户管理</title>
<orderedlist>
<listitem>
<para>
如果使能了Lockout功能，则需要建立两个系统管理员帐号，以防止一个被锁定（如多次错误登录被无限期死锁），能用另外一个解锁。
</para>
</listitem>
<listitem>
<para>
建组原则（假设组名为 team1）
</para>
<itemizedlist>
<listitem>
<para>
建立用户组和子组
</para>
<para>
假设组名为 team1，首先建立一个大组 ga_team1 组；再在 team1 组下再建立三个child group: g_team1_admin 组，g_team1_users 组和 g_team1_rdonly 组（即只读组）。
</para>
</listitem>
<listitem>
<para>
建组的考虑
</para>
<para>
将权限分配到组，是管理权限的基本原则。因为 starteam 在赋予权限时，是将用户名和组名混在一起，因此为组名加上前缀 “g_” 或者 “ga_”。区分 g_ 和 ga_ 是因为要防止误将权限设置到更大的 ga_ 组中（如后所述）。
</para>
<para>
组管理员属于 g_team1_admin 组，拥有管理 LABEL 权限，创建新视图，以及管理代码权限分配权限；starteam管理员部分授权，目的是减少starteam管理员的管理负担。提高效率。
</para>
<para>
小组的其它用户属于 g_team1_users 组，除了不具有 g_team1_admin 组的管理权限外，其它权限同 g_team1_admin。
</para>
<para>
对于其它有研读代码或者掌握进度需求的用户，如 QA、部门领导等属于 g_team1_rdonly 组，除了具有只读方式看代码权限外，其它同 all users。
</para>
<para>
建立项目组 ga_project_manager，是独立于项目组（也可以考虑为每个项目组单独设置），进行项目管理。为管理需求变更，在其下建立 g_pm_req；为管理TODO LIST，建立 g_pm_todo组。
</para>
<warning>
<para>
分配权限时，要注意不要把权限赋予大组（如 ga_team1 组）。因为 team1 组包括了 g_team1_rdonly 组（只读用户组）！
</para>
</warning>
</listitem>
<listitem>
<para>
关于组本身的权限
</para>
<para>
除 Administrators 组外，任何组不要设置组的权限，以免组的权限设置超越了项目的安全设置，使对项目的安全设置形同虚设。
</para>
</listitem>
</itemizedlist>
</listitem>

<listitem>
<para>
关于发布机使用独立用户
<anchor id="user-releng"/>
</para>
<para>
在UNIX命令行上进行代码的check in/check out，需要建立独立用户，如：team1_release。以免由于使用同一个用户名在不同工作站check代码，造成文件状态UNKNOWS的情况。参见Starteam Howto中关于文件状态unknown的FAQ。
</para>
</listitem>

</orderedlist> 
</sect3>

<sect3 id="server"><title>服务器配置的安全设置</title>

<orderedlist>
<listitem>
<para>Starteam VTS 的启动方式设置为NT服务方式
</para>
<para>
保证服务器重启后，Starteam自动启动。
</para>
</listitem>

<listitem>
<para>
Starteam 服务器端配置
</para>
<anchor id="server-vts-config"/>
<itemizedlist>
<listitem>
<para>
General
</para>
<para>
设置登录超时60秒，未动作超时300分钟。
</para>
</listitem>
<listitem>
<para>
Audits
</para>
<para>
设置只保留10天安全日志。
</para>
</listitem>
<listitem>
<para>
Vault
</para>
<para>
设置不清除文件状态表；
</para>
<para>
设置最大CACHE为400MB。
</para>
<para>
设置Cache的文件夹在Valut文件夹之外，以使在备份时，对cache区别对待
（不备份Cache）。
</para>
</listitem>
<listitem>
<para>
Notifications
</para>
<para>
使能Email通知。
</para>
</listitem>
<listitem>
<para>
Protocal
</para>
<para>
只保留一种协议支持：TCP/IP(SOCKETS)，因为别的协议支持有问题；
</para>
<para>
TCP/IP加密级别：不作设置，但是管理员要通知用户，如果客户端支持传输加密，请至少选择RSA R4 stream加密。windows客户端都支持，但是unix命令行不支持。
</para>
</listitem>
</itemizedlist>
</listitem>

<listitem>
<para>访问权限（Access Rights）
</para>
<para>管理员完全权限，不赋予其它用户任何权限。
</para>
</listitem>
<listitem>
<para>系统策略（System Policy）
</para>
<itemizedlist>
<listitem>
<para>Access Rights
</para>
<para>使能 Ignore object ownership, 即忽略OwnerShip，一切均按照权限设置。
</para>
<para>不选择 Ignore group privileges, 即在保证只有 Administrators 组设置了组权限情况下，允许Administrators组用户超越项目的权限限制实施管理。
</para>
</listitem>
<listitem>
<para>Security Events
</para>
<para>设置只保留30天的安全日值。
</para>
</listitem>
<listitem>
<para>Passwords
</para>
<para>设置密钥最小长度6个字符。
</para>
</listitem>
<listitem>
<para>在用户管理（User manager）界面，设置所有用户第一次登录必须修改口令，并且不允许设置空口令。
</para>
</listitem>
<listitem>
<para>Logon Failures
</para>
<para>设置5次失败登录锁定帐号，帐号锁定5分钟。
</para>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</sect3>

<sect3 id="project-right"><title>工程的权限设置</title>
<para>先打开要配置的工程，Project->Access Rights，来设置工程权限。
</para>
<orderedlist>
<listitem>
<para>Project
</para>
<itemizedlist>
<listitem>
<para>
All Users
</para>
<para>
设置所有用户（All Users）具有如下权限:
</para>
<para>
See Project and Properties
</para>
</listitem>
<listitem>
<para>
g_xxx_admin
</para>
<para>
设置组管理员（如：g_team1_admin 组）具有如下权限：
</para>
<para>
赋予除了 Delete project 外所有权限。以便于管理员修改自身权限，给自己加上删除label权限等，但要注意缺省没有赋予管理员的权限，当管理员完成相应管理功能后，恢复原状。
</para>
<warning>
<para>不能赋给任何人删除工程权限！因为工程删除不可逆。
</para>
</warning>
</listitem>
</itemizedlist>
</listitem>

<listitem>
<para>Views
</para>
<itemizedlist>
<listitem>
<para>
All Users
</para>
<para>
设置所有用户（All Users）具有如下权限：
</para>
<para>
See View and its Properties
</para>
</listitem>
<listitem>
<para>
g_xxx_admin
</para>
<para>
设置组管理员（如：g_team1_admin 组）具有如下权限：
</para>
<para>
赋予除了 Delete View, Delete Labels 外所有权限。
</para>
</listitem>
</itemizedlist>
<warning>
<para>
Delete View, Delete Labels 不可逆，因此不赋予任何人此权限。但为了减轻管理员负担，赋予了 g_team1_admin 组 change view security setting 权限，g_team1_admin可以修改自己权限，使具有删除 label, 甚至是删除 view 权限，但要注意完成维护功能后，立即去掉该两项权限！
</para>
</warning>
</listitem>

<listitem>
<para>Child Folders
</para>
<itemizedlist>
<listitem>
<para>
g_team1_rdonly 组
</para>
<para>
设置只读组（如：g_team1_rdonly 组）具有如下权限：
</para>
<para>
具有：See folder and its properties, See folder history, See folder links
权限。
</para>
</listitem>
<listitem>
<para>
g_team1_users 组
</para>
<para>
设置普通用户组（g_team1_users 组）具有如下权限：
</para>
<para>
除 Modify folder properties, Delete folder from parent folder, 
Change folder security set 外所有权限。
</para>
</listitem>
<listitem>
<para>
g_team1_admin组
</para>
<para>
设置组管理员（如：g_team1_admin 组）具有如下权限：
</para>
<para>
除了 Delete folder from parent folder 外所有权限。
</para>
</listitem>
</itemizedlist>
</listitem>

<listitem>
<para>Files
</para>
<itemizedlist>
<listitem>
<para>
g_team1_rdonly 组
</para>
<para>
设置只读组（如：g_team1_rdonly 组）具有如下权限：
</para>
<para>
具有：See file and its properties, See file history, See file links,
Check out files 权限。
</para>
</listitem>
<listitem>
<para>
g_team1_users 组
</para>
<para>
设置普通用户组（g_team1_users 组）具有如下权限：
</para>
<para>
除 Change file security set 外所有权限。
</para>
</listitem>
<listitem>
<para>
g_team1_admin 组
</para>
<para>
设置组管理员（如：g_team1_admin 组）具有如下权限：
</para>
<para>
所有权限。
</para>
<warning>
<para>
Move folder out of a view or project 权限也是危险操作，文件移出视图，也从历史视图中去掉，可能会破坏完整性。但将文件或目录移动到另外一个视图，是从服务器端删除文件的唯一办法。因此慎用。
</para>
</warning>
</listitem>
</itemizedlist>
</listitem>


<listitem>
<para>Change Request
</para>
<itemizedlist>
<listitem>
<para>
All Users
</para>
<para>
添加所有用户（All Users），将权限设置为空。即默认禁止一切的策略。
</para>
</listitem>
</itemizedlist>
<note>
<para>
工程的权限设置中的ChildFolders, Files, Change request 等的权限设置，用来确定工程的默认设置。即为没有对各项进行单独权限设置时的默认安全设置。 
</para>
<para>
将 Change Request 定义为默认禁止一切，目的是只在指定目录添加 Change Request.
</para>
</note>
</listitem>

<listitem id="priv-proj-topic">
<para>Topics
</para>
<itemizedlist>
<listitem>
<para>
All Users
</para>
<para>
设置所有用户（All Users）具有如下权限：
</para>
<para>
设置除了 “Change topic security set”，“Delete Topic from folder”外所有权限。提供用户通过 TOPIC 进行讨论以及保存备忘。
</para>
</listitem>
<listitem>
<para>设置组管理员（如：g_team1_admin 组）具有所有权限。
</para>
</listitem>
</itemizedlist>
</listitem>

</orderedlist> 
</sect3>

<sect3 id="view-right"><title>视图的权限设置</title>
<para>
先打开要配置的视图，View->Access Rights，来设置视图权限。
</para>
<orderedlist>
<listitem>
<para>
根视图
</para>
<para>
可以不设置权限，继承整个工程中的Project AccessRight的 Views 的各项权限设置。
</para>
</listitem>
<listitem>
<para>
分支视图
</para>
<para>
按需设置。可以使老版本的维护由其他人完成，或者进行 xp 模式开发，为开发者（非管理员）设置更大的权限。
</para>
</listitem>
</orderedlist> 
</sect3>

<sect3 id="folder-right"><title>文件夹的权限设置</title>
<para>
选择视图下相应文件夹，鼠标右键单击，选择 Advanced->Access Rights，设置权限。
</para>
<para>
需要先设置“根目录”权限。再单独设置各一级子目录（defect, src, doc等）的权限。如果需要还可以对二级目录等（模块）设置权限，但不建议设置二级目录的权限。
</para>
<orderedlist>
<listitem>
<para>
根目录
</para>
<para>
根目录和子目录在权限设置上的异同
</para>
<orderedlist>
<listitem>
<para>
根目录的权限不传递，即在根目录上设置的权限对派生的子视图没有影响；而非根目录会传递权限，所以尽量不要在子目录（非根目录）上设置权限，以免连带影响其它视图中该目录的权限，造成混乱。
</para>
</listitem>
<listitem>
<para>
根目录继承视图或者工程的 Child Folder 权限；子目录先继承根目录权限，
再继承视图，工程权限。
</para>
</listitem>
<listitem>
<para>
因此，不要设置根目录的权限页的 Child Folder 页，这样没有设置权限的子目录便可以继承视图的 Child Folder页的权限。但是可能需要设置根目录权限页的 This Folder 页，因为 This Folder的权限默认取自视图或者工程的 Child Folder 设置。如果有子目录的权限大于视图或者工程的 Child Folder的设置，就需要设置This Folder 设置。但是副作用是，子目录的权限并没有完全继承视图或者工程的更严格的设置，而是采用了根目录的 This Folder 设置和 视图的Subfolder设置的组合（因为根目录没有设置Subfolder权限）。这样有可能使所有能够访问根目录的用户访问整个目录树！！！好像没有更好的解决方案。
</para>
</listitem>
</orderedlist>
<para>
根目录上的权限设置：
</para>
<itemizedlist>
<listitem>
<para>
This Folder
</para>
<para>
All Users：所有用户（All Users）具有 See folder and its properties, See folder history, See folder links 权限。
</para>
<para>
g_team1_admin： 组管理员（g_team1_admin）具有：除了Delete folder from parent folder 外所有权限。
</para>
</listitem>
<listitem>
<para>Child Folders，Files, Change Requests, Tasks, Topics
</para>
<para>
不作设置，以继承视图或者工程的权限设置。
</para>
</listitem>
</itemizedlist>
</listitem>

<listitem>
<para>
Defect目录
</para>
<itemizedlist>
<listitem>
<para>
This Folder
</para>
<para>
All Users ： 所有用户（All Users）具有—— See folder and its properties, See folder history, See folder links 权限。
</para>
<para>
g_qa_admin：QA组管理员（g_qa_admin）具有——除了Delete folder from parent folder 外所有权限。
</para>
<para>
g_team1_admin：team1组管理员（g_team1_admin）具有——除了Delete folder from parent folder 外所有权限。
</para>
<note>
<para>
设置服务QA管理员和team1目录管理权限，允许QA管理员建立子目录，用于对CR分类。
</para>
</note>
</listitem>
<listitem>
<para>Child Folders
</para>
<para>
All Users：所有用户（All Users）具有——See folder and its properties, See folder history, See folder links 权限。
</para>
<para>
g_qa_admin：QA组管理员（g_qa_admin）具有——除了Delete folder from parent folder 外所有权限。
</para>
<para>
g_team1_admin：team1组管理员（g_team1_admin）具有——除了Delete folder from parent folder 外所有权限。
</para>
</listitem>
<listitem>
<para>Change Requests
</para>
<para>All Users：所有用户（All Users）具有——除了Change CR Security set , Delete CR from folder外所有权限。
</para>
<para>
g_qa_admin：QA组管理员（g_qa_admin）具有——除了Delete CR from folder 外所有权限。
</para>
<warning>
<para>
为了减轻管理员负担，赋予了 g_qa_admin 组 change CR security setting 权限，g_qa_admin可以修改change request的权限，使之可以被删除，再删除该 cr。
</para>
</warning>
</listitem>
<listitem>
<para>Files, Tasks, Topics
</para>
<para>不另外设置权限，继承视图或者工程的权限。
</para>
</listitem>
</itemizedlist>
</listitem>

<listitem>
<para>
src 目录
</para>
<para>
src 目录是用来存放源代码的目录，应着重注意本目录权限设置。
</para>
<para>
可以不作任何单独设置，因为继承了视图或者工程的权限设置。如果工程或者视图关于文件的权限设置足够安全的话，可以不必设置本目录权限。
</para>
</listitem>

<listitem>
<para>
ProjectManagement 目录
</para>
<para>
ProjectManagement 目录，用于以文件和 TOPIC形式存储 TODO_LIST, 编程规范，需求变更。
</para>
<orderedlist>
<listitem>
<para>
ProjectManagement 目录
</para>
<itemizedlist>
<listitem>
<para>
This Folder
</para>
<para>
All Users ：所有用户具有—— See folder and its properties, See folder history, See folder links 权限。
</para>
<para>
ga_project_manager 组 ：具有——除 Modify folder properties, Delete folder from parent folder, Change folder security set 外所有权限。
</para>
<para>
g_team1_admin组 ：具有——除 Delete folder from parent folder 外所有权限。
</para>
</listitem>
<listitem>
<para>Child Folders
</para>
<para>
All Users ：所有用户具有—— See folder and its properties, See folder history, See folder links 权限。
</para>
<para>
ga_project_manager 组 ：具有——除 Modify folder properties, Delete folder from parent folder, Change folder security set 外所有权限。
</para>
<para>
g_team1_admin组 ：具有——除 Delete folder from parent folder 外所有权限。
</para>
</listitem>

<listitem>
<para>Files
</para>
<para>
All Users：具有——See file and its properties, See file history, See file links, Check out files 权限。
</para>
<para>
ga_project_manager：普通用户组具有——除了 Change file security set, Delete file from folder 外的所有权限。
</para>
<para>
g_team1_admin：组管理员具有——除了 Delete file from folder 外的所有权限。
</para>
</listitem>

<listitem>
<para>
Topic
</para>
<para>
All Users：具有——除了 Change top security set, Delete topic from forder 外所有权限。
</para>
<para>
g_team1_admin：具有——除了 Delete topic from forder 外所有权限。
</para>
</listitem>

<listitem>
<para>Change
</para>
<para>暂不设置，采用工程缺省禁用配置。
</para>
</listitem>
</itemizedlist>
</listitem>

<listitem>
<para>
TODO LIST子目录
</para>
<para>
所有用户具有只读文件，读写TOPIC权限；g_pm_todo 组 和 g_team1_admin组具有读写文件，读写topic，和整理目录权限。
</para>
</listitem>

<listitem>
<para>
编程规范
</para>
<para>
所有用户都有整理目录，读写topic权限；g_team1_admin 多了一项管理文件的权限。
</para>
</listitem>

<listitem>
<para>
需求变更
</para>
<para>
所有用户具有只读文件，只读TOPIC权限；g_pm_req 组 和 g_team1_admin 组具有读写文件，读写topic，和整理目录权限。
</para>
</listitem>
</orderedlist>

</listitem>
</orderedlist>

</sect3>

<sect3 id="maintenance"><title>Starteam服务器优化</title>
<sect4><title>提高数据库性能</title>
<itemizedlist>
<listitem>
<para>数据库可以有多种选择，但是ACCESS基本可以满足需求，虽然有1.2G文件大小限制，但一般应用不会超过。数据库的选择不是性能瓶颈。
</para>
</listitem>
<listitem>
<para>安装和使用 Copy Indexes Tools in "StarTeam VirtualTeam Server 4.0\Tuning Scripts\MS Access\Package"。
</para>
</listitem>
<listitem>
<para>压缩数据库；（ODBCàsystem dsn）
</para>
</listitem>
<listitem>
<para>增加数据库的Max Buffer size从2048至8192，Threads 从3至 24。
</para>
</listitem>
<listitem>
<para>关于其他数据库，参见
<ulink url="http://devforum.starbase.com/starbase/Main.asp">
http://devforum.starbase.com/starbase/Main.asp</ulink>
</para>
</listitem>
</itemizedlist>
</sect4>

<sect4><title>提高Starteam服务器性能</title>
<itemizedlist>
<listitem>
<para>增加Cache目录文件大小至400M；
</para>
</listitem>
<listitem>
<para>将文件状态表导出时间从180天减少到30天；
</para>
</listitem>
<listitem>
<para>将审计导出时间从不导出更改为30天导出；
</para>
</listitem>
<listitem>
<para>在客户端设置Allow  check out of deltas
"Tools | Workstation | Files "Optimize for slow connection.""
</para>
</listitem>
<listitem>
<para>参见<ulink url=
"http://devforum.starbase.com/starbase/Articles/Default.asp?id=206">
http://devforum.starbase.com/starbase/Articles/Default.asp?id=206
</ulink>
</para>
</listitem>
</itemizedlist>
</sect4>

<sect4><title>备份</title>
<para>备份涉及到： 
</para>
<itemizedlist>
<listitem>
<para>The Configuration and cipher files
</para>
<para>Configuration\server.scg
</para>
<para>Configuration\server.cph 
</para>
</listitem>
<listitem>
<para>Database files
</para>
<para>Database\StarTeamDB.mdb (Assuming Access database)
</para>
</listitem>
<listitem>
<para>Vault: 
</para>
<para>Archive dir: *.*
</para>
<para>Attachments dir: *.* 
</para>
</listitem>
<listitem>
<para>Optional
</para>
<para>Cache dir: *.* 
</para>
</listitem>
</itemizedlist>
<para>
参见http://devforum.starbase.com/starbase/Articles/Default.asp?id=133
</para>
</sect4>

</sect3>
</sect2>

</sect1>

<sect1 id="vs-svrstore"><title>CVS vs. STARTEAM——服务器端存储</title>
<sect2><title>CVS 服务器端存储</title>
<screen>
$ pwd
/repos/local

$ ls -l
total 0
drwxr-xr-x    3 Administ None            0 Dec 14 20:59 CVSROOT
drwxr-xr-x   12 Administ None            0 Dec 29 21:47 worldhello

$ ls CVSROOT   
Emptydir        commitinfo,v    cvswrappers,v   loginfo         notify          rcsinfo,v       val-tags
checkoutlist    config          editinfo        loginfo,v       notify,v        readers         verifymsg
checkoutlist,v  config,v        editinfo,v      modules         passwd          taginfo         verifymsg,v
commitinfo      cvswrappers     history         modules,v       rcsinfo         taginfo,v

$ cd worldhello

$ ls -F
bio/     docbook/   html/    inc/          life/   resource/  utility/
daily,v  favorite/  images/  index.html,v  make,v  sports/

$ head index.html,v
head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 jiangxin:1.1.1;
locks    ; strict;
comment  @# @;


1.1
date     2002.12.29.13.47.00;  author jiangxin;  state Exp;
</screen>
<para>
可以看出CVS的服务器端存储和客户端的是一一对应的，树形的文件系统。
</para>
</sect2>

<sect2><title>Starteam 服务器端存储</title>
<note>
<para>
以下的示意，是在 Win2k 平台，在 cygwin 命令行下输出
</para>
</note>
<para>
Starteam 的数据库
</para>
<screen>
$ pwd
/d/.repos/STARTEAM/johnson/Database

$ ls -l
-rw-r--r--    1 Administ None      2101248 Sep  5 20:22 StarTeamDB.mdb
</screen>

<para>
版本控制文件 
</para>
<screen>
$ pwd
/d/.repos/STARTEAM/johnson/Vault/Archive

$ ls -F
00000000  00000006  0000000C  00000012  00000018  0000001E  00000024  0000002A
00000001  00000007  0000000D  00000013  00000019  0000001F  00000025  0000002B
00000002  00000008  0000000E  00000014  0000001A  00000020  00000026
00000003  00000009  0000000F  00000015  0000001B  00000021  00000027
00000004  0000000A  00000010  00000016  0000001C  00000022  00000028
00000005  0000000B  00000011  00000017  0000001D  00000023  00000029
</screen>

<para>
缓存
</para>
<screen>
$ pwd
/d/.repos/STARTEAM/CACHE/johnson

$ ls -F
00000000.1  00000001.3  00000007.1  00000011.1  0000001B.1  00000025.1
00000000.2  00000001.4  00000008.1  00000012.1  0000001C.1  00000026.1
00000000.3  00000001.5  00000009.1  00000013.1  0000001D.1  00000027.1
00000000.4  00000001.6  0000000A.1  00000014.1  0000001E.1  00000028.1
00000000.5  00000002.1  0000000B.1  00000015.1  0000001F.1  00000029.1
00000000.6  00000002.2  0000000C.1  00000016.1  00000020.1  0000002A.1
00000000.7  00000003.1  0000000D.1  00000017.1  00000021.1  0000002B.1
00000000.8  00000004.1  0000000E.1  00000018.1  00000022.1
00000001.1  00000005.1  0000000F.1  00000019.1  00000023.1
00000001.2  00000006.1  00000010.1  0000001A.1  00000024.1
</screen>
<para>
可以看出Starteam的服务器端存储和客户端完全不同，服务器端文件存储结构是平面结构。文件名和实际物理存储的对应是通过数据库来实现的。
</para>

</sect2>
</sect1>

<sect1 id="vs-client"><title>CVS vs. STARTEAM——客户端设置</title>
<sect2><title>CVS 客户端设置</title>
<itemizedlist>
<listitem>
<para>
设置 CVSROOT 环境变量 或者命令行中指定
</para>
<screen>
# 如： 
export CVSROOT=:pserver:jiangxin@10.0.0.152:/home/repos-user
# 或者： 
cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user  login
</screen>
<note>
<para>
以下的 cvs 命令行示意，都假定已经设置了环境变量 CVSROOT。
</para>
</note>
</listitem>

<listitem>
<para>
登录，将密码记录在本地
</para>
<screen>
cvs login
# 则口令自动保存在 $HOME/.cvspass 中
# cat $HOME/.cvspass
:pserver:releng@10.0.0.61:/lt/repos xxxx
:pserver:yzw@10.0.0.61:/lt/repos xxxxx
:pserver:yzw@10.0.0.152:/home/repos-user xxx
:pserver:jiangxin@10.0.0.61:/repos/home xxxxxx
:pserver:jiangxin@10.0.0.152:/home/repos-user xxxxx
:pserver:anonymous@10.0.0.152:/home/repos-user xxxxx
:pserver:anoncvs@anoncvs1.ca.openbsd.org:/cvs xxxxxx
:pserver:anoncvs@anoncvs.FreeBSD.org:/home/ncvs xxxxxxxxx
</screen>
</listitem>

<listitem>
<para>
查看 CVS 中现有的模块
</para>
<para>
cvs co -c
</para>
<screen>
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -c
CVSROOT      CVSROOT
all-in-one   pub/docbook
johnson      -a jiangxin
wuzj         wuzj &amp;docbook/ltfw_changes
</screen>
</listitem>

<listitem>
<para>
将模块 Checkout 到本地
</para>
<screen>
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d johnson_homepage jiangxin
</screen>
<para>
将:pserver:jiangxin@10.0.0.152:/home/repos-user中的模块 jiangxin  CHECKOUT 到本地 johnson_homepage 目录。
</para>
</listitem>

<listitem>
<para>
本地配置文件
</para>
<para>
CVS 通过在本地源码目录同时保存配置信息（CVS目录）来记录源文件的版本等
</para>
<screen>
# pwd
/home/jiangxin/work/johnson_homepage

# ls -l CVS
total 14
-rw-r--r--  1 root  jiangxin  4786 Sep  5 10:32 Entries
-rw-r--r--  1 root  jiangxin     9 Jul 23 10:01 Repository
-rw-r--r--  1 root  jiangxin    43 Jul 23 10:01 Root

# cat CVS/Repository 
jiangxin

# cat CVS/Root      
:pserver:jiangxin@10.0.0.152:/home/repos-user

</screen>
</listitem>
</itemizedlist>
</sect2>

<sect2><title>Starteam 客户端设置</title>
<para>
下面以我们自己，(最早由杨致伟封装，后经 Johnson 改写)，封装的 Starteam 命令行 Wrapper 为例作以介绍：
</para>
<itemizedlist>
<listitem>
<para>
用 st config 进行配置
</para>
<screen>
# cd /home/jiangxin/work/src/project
# mkdir branch1
# cd branch1
# pwd
/home/jiangxin/work/src/project/branch1

# st config
StarTeam Configuration


Original starteam server is 10.0.0.60
new server:[10.0.0.60]
Original starteam server port is 49201
new server port:[49201]
original username is 
new username:[]jiangxin
Password:[********]
Confirm :[********]
Original checkout project is project
Project you want to checkout:[project]
Original checkout view is  ("/" means root view)
View you want to checkout:[]branch_2_4
Original checkout folder is  ("/" means root folder)
Folder you want to checkout:[]Development
Working dir is /usr/home/jiangxin/work/src/project/branch1
Your working directory:[/usr/home/jiangxin/work/src/project/branch1]
Sticky tag base on date :  ("/" means not exist)
Date:[]
Sticky tag base on label :  ("/" means not exist)
Label:[]
Sticky tag base on promotion-state :  ("/" means not exist)
Promotion-state:[]

# cat .starteam.ini 
# StarTeam Configuration: /usr/home/jiangxin/work/src/project/branch1/.starteam.ini
# /usr/home/jiangxin/work/src/project/branch1/.starteam.ini
STUSER="jiangxin"
STSERVER="10.0.0.60"
STPORT="49201"
STPROJECT="project"
STVIEW="branch_2_4"
STFOLDER="Development"
STCFGD=""
STCFGL=""
STCFGP=""
STWORKROOT="/usr/home/jiangxin/work/src/project/branch1"

</screen>
</listitem>

<listitem>
<para>
用户登录口令保存在用户主目录下
</para>
<para>
用 st config 配置完成，或者用命令 st login 登录后，用户口令自动保存在 $HOME/.stpass 中
</para>
<screen>
# cat $HOME/.stpass
releng:10.1.1.60:49201:xxxxxxxxxxxxxxxx
jiangxin:10.1.1.60:49201:xxxxxxx
jiangxin:10.0.0.6:49201:xxxxxxxx
</screen>
</listitem>

<listitem>
<para>
将代码 Checkout 到本地
</para>
<screen>
# pwd
/home/jiangxin/work/src/project/branch1

# st co
Folder: Development  (working dir: /usr/home/jiangxin/work/src/project/branch1)
Makefile: checked out
.......
</screen>
<para>
将配置文件 .starteam.ini 文件指定的视图下的文件，Checkout 到本地
</para>
<tip>
<para>
如果不想将全部模块 Checkout 到本地，可先运行命令 st cd ，将整个目录结构 Checkout 到
本地，然后再运行 st co directory，只 checkout 该目录。
</para>
</tip>
</listitem>
<listitem>
<para>
本地配置文件
</para>
<para>
STARTEAM 不是像 CVS 那样，在本地源码目录同时保存配置信息（CVS目录）来记录源文件的版本等，
而是直接保存在服务器的数据库中。而该数据库通过主机ID，来区分不同/相同用户在同一/不同主机
中 CHECKOUT 文件的路径等信息。
</para>
<para>
命令行用 $HOME/.starteam 保存主机ID等配置信息。图形界面类似。
</para>
<para>
starteam cli wrapper 另外需要配置文件： .starteam.ini，因为命令行没有提供简单的读取服务器端
数据库的方法。
</para>
</listitem>

</itemizedlist>
</sect2>


</sect1>

<sect1 id="vs-cmd"><title>CVS vs. STARTEAM——常用版本控制操作</title>

<table frame='all'><title>CVS, Starteam 常用命令比较</title>
<tgroup cols='3' align='left' colsep='1' rowsep='1'>
<colspec colname='c1'/>
<colspec colname='c2'/>
<colspec colname='c3'/>
<thead>
<row>
  <entry>CVS 命令</entry>
  <entry>Starteam 命令</entry>
  <entry>说明</entry>
</row>
</thead>
<tbody>
<row>
  <entry>
  cvs co -D "2002-09-2 20:05" ltfilter
  </entry>
  <entry>
  st co --cfgd "12/29/97 10:52 AM" *
  </entry>
  <entry>
  Checkout 某一时刻前的代码
  </entry>
</row>
<row>
  <entry>
  cvs up -l
  </entry>
  <entry>
  st up -l
  </entry>
  <entry>
  只更本目录下文件，不更新子目录
  </entry>
</row>
<row>
  <entry>
  cvs up -A
  </entry>
  <entry>
  st up -A
  </entry>
  <entry>
  更新为最新的代码，对于cvs, 如果是分支视图，要用" -r &lt;分支TAG&gt; "
  </entry>
</row>
<row>
  <entry>
  cvs up -r &lt;tag_name&gt;
  </entry>
  <entry>
  st up -r &lt;label_name&gt;
  </entry>
  <entry>
  Checkout 某一 tag/label 的代码
  </entry>
</row>
<row>
  <entry>
  cvs ci -m "commit log..."   &lt;filename&gt;
  </entry>
  <entry>
  st ci -m "commit log..."  &lt;filename&gt;
  </entry>
  <entry>
  Checkin 文件
  </entry>
</row>
<row>
  <entry>
  
  </entry>
  <entry>
  st ci -m "commit log..." --filter m
  </entry>
  <entry>
  Checkin 状态为 Modified 的文件
  </entry>
</row>
<row>
  <entry>
  <para>
  cvs add -kb &lt;binaryfile&gt;
  </para>
  <para>
  cvs commit -m "file add log... ..."
  </para>
  </entry>
  <entry>
  st add &lt;binaryfile&gt;
  </entry>
  <entry>
  添加新文件
  </entry>
</row>
<row>
  <entry>
  <para>
  cvs remove &lt;filename&gt;
  </para>
  <para>
  cvs commit -m "file remove log... ..."
  </para>
  </entry>
  <entry>
  <para>
  st delete-local &lt;filename&gt; (删除本地文件)
  </para>
  <para>
  st remove-repos &lt;filename&gt; (删除服务器文件)
  </para>
  </entry>
  <entry>
  删除文件
  </entry>
</row>
<row>
  <entry>
  cvs diff -c -r 1.5 -r 1.7 &lt;filename&gt;
  </entry>
  <entry>
  st diff -r 1.5 -r 1.7 &lt;filename&gt;
  </entry>
  <entry>
  比较文件&lt;filename&gt; 1.5 和 1.7 版本的区别
  </entry>
</row>
<row>
  <entry>
  cvs status -v &lt;filename&gt;
  </entry>
  <entry>
  
  </entry>
  <entry>
  查看当前的 label
  </entry>
</row>
<row>
  <entry>
  cvs log &lt;filename&gt; | more
  </entry>
  <entry>
  st log &lt;filename&gt; | more
  </entry>
  <entry>
  查看commit logs.
  </entry>
</row>
<row>
  <entry>
  cvs -n up -l
  </entry>
  <entry>
  st list -l
  </entry>
  <entry>
  显示当前目录文件状态
  </entry>
</row>
<row>
  <entry>
  cvs co -c
  </entry>
  <entry>
  
  </entry>
  <entry>
  显示模块/工程名
  </entry>
</row>
<row>
  <entry>
  cvs rtag [ -r &lt;branch_tag_name&gt; ] &lt;tag_name&gt;  &lt;module_name&gt;
  </entry>
  <entry>
  <para>
  st new-viewlabel --label &lt;label_name&gt; 
  </para>
  <para>
  st label --label &lt;label_name&gt; 
  </para>
  </entry>
  <entry>
  为模块打 tag/label
  </entry>
</row>
<row>
  <entry>
  cvs rtag -b [ -r &lt;base_branch_name&gt; ] &lt;new_branch_name&gt;  &lt;module_name&gt;
  </entry>
  <entry>
  图形界面
  </entry>
  <entry>
  建立分支
  </entry>
</row>
<row>
  <entry>
  cvs -d :pserver:jiangxin@10.0.0.217:/repos init
  </entry>
  <entry>
  <para>
  st new-viewlabel --label &lt;label_name&gt; 
  </para>
  <para>
  st label --label &lt;label_name&gt; 
  </para>
  </entry>
  <entry>
  为模块打 tag/label
  </entry>
</row>
<row>
  <entry>
  <para>
  cd wdir
  </para>
  <para>
  cvs import -m "Imported sources" yoyodyne/rdir yoyo start
  </para>
  </entry>
  <entry>
  
  </entry>
  <entry>
  建立新工程
  </entry>
</row>
</tbody>
</tgroup>
</table>

</sect1>

<sect1 id="cvs-modshare"><title>CVS vs. STARTEAM——模块间共享</title>
<sect2><title>CVS 中的文件和目录的共享</title>
<para>
客户端通过本地配置文件（CVS目录中的文件），来记录存储信息，因此可以在客户端
的一个目录树下，维护多个工程、不同分支代码，甚至是不同CVS服务器的代码。
</para>
<para>
还可以通过服务器端配置文件：CVSROOT/modules，来将不同目录、文件组合
成单独的模块，免除了客户端在一个目录树下多次 Check 不同目录的繁琐。
</para>
<para>
如下两个方式Check代码等同，但显然第一种方式好。
</para>
<para>
方式一： 通过服务器端的 modules 配置文件控制
</para>
<screen>
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co CVSROOT
# cd CVSROOT
# vi modules
######## modify modules file as the follows:
johnson_homepage jiangxin/web &amp;docbook/project &amp;docbook/nightlybuild \
             &amp;docbook/pm_fw_plan_2_4 &amp;docbook/steam_trans \
             &amp;docbook/docbook_howto &amp;docbook/pgp &amp;docbook/program_rules \
             &amp;docbook/tip_sysconfig &amp;docbook/images &amp;docbook/pm_fw_diary_2_4 \
             &amp;docbook/rd_hwenv &amp;docbook/steam_admin &amp;docbook/tip_sysinstall \
             &amp;docbook/lession_scm &amp;docbook/pm_fw_module_debug \
             &amp;docbook/steam_howto

# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -c
＃ 显示服务器端配置文件 modules 的内容
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d web johnson_homepage
＃ Checkout 代码
</screen>

<para>
方式二： 通过在客户端，在目录树下不同的目录执行不同的 Checkout 动作实现。
</para>
<screen>
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d web jiangxin/web
# cd web
# ls
# mkdir docbook
# cd docbook
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d project           docbook/project
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d nightlybuild        docbook/nightlybuild
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d pm_fw_plan_2_4      docbook/pm_fw_plan_2_4
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d steam_trans         docbook/steam_trans
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d docbook_howto       docbook/docbook_howto
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d pgp                 docbook/pgp
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d program_rules       docbook/program_rules
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d tip_sysconfig       docbook/tip_sysconfig
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d images              docbook/images
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d pm_fw_diary_2_4     docbook/pm_fw_diary_2_4
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d rd_hwenv            docbook/rd_hwenv
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d steam_admin         docbook/steam_admin
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d tip_sysinstall      docbook/tip_sysinstall
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d lession_scm         docbook/lession_scm
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d pm_fw_module_debug  docbook/pm_fw_module_debug
# cvs -d :pserver:jiangxin@10.0.0.152:/home/repos-user co -d steam_howto         docbook/steam_howto
</screen>

<para>
服务器端目录结构
</para>
<screen>
# pwd
/home/repos-user

# mtree -cdin  -k type   

#          user: jiangxin
#       machine: openbsd
#          tree: /usr/home/repos-user
#          date: Tue Sep 10 21:34:26 2002
/set type=dir
.              
    CVSROOT        
        Emptydir       
        ..
    ..
    docbook        
        project      
        ..
        docbook_howto  
        ..
        images         
            callouts       
            ..
        ..
        lession_scm    
        ..
        nightlybuild   
        ..
        pgp            
            images         
            ..
        ..
        pm_fw_diary_2_4
        ..
        pm_fw_module_debug
        ..
        pm_fw_plan_2_4 
            Attic          
            ..
        ..
        program_rules  
        ..
        rd_hwenv       
        ..
        samples        
        ..
        steam_admin    
        ..
        steam_howto    
            images         
            ..
        ..
        steam_trans    
        ..
        tip_sysconfig  
        ..
        tip_sysinstall 
            images         
            ..
        ..
    ..
    jiangxin       
        text           
            apache         
            ..
            config.network.linux
            ..
            db.mysql       
            ..
            db.oracle      
                Attic          
                ..
            ..
            dns.bind       
            ..
            email.qmail    
            ..
            kernel.linux   
            ..
            security.linux 
            ..
            security.ssh   
            ..
            utility.cvs    
            ..
            utility.samba  
            ..
            utility.xwindow
            ..
        ..
        web            
            Attic          
            ..
            doc            
            ..
            html           
                resources      
                ..
            ..
            images         
                gif            
                ..
                png            
                ..
                xpi            
                ..
                xpm            
                ..
            ..
            resource       
                html           
                ..
                ipaddr         
                ..
                mailaddr       
                ..
                pgpkey         
                ..
            ..
            utility        
                ltutil         
                ..
            ..
        ..
    ..
..
</screen>

<para>
客户端目录结构
</para>
<screen>
# mtree -cdin  -k type 

#          user: jiangxin
#       machine: openbsd
#          tree: /usr/home/jiangxin/work/test
#          date: Tue Sep 10 21:24:33 2002
/set type=dir
.              
    web            
        CVS            
        ..
        doc            
            CVS            
            ..
        ..
        docbook        
            CVS            
            ..
            project      
                CVS            
                ..
            ..
            docbook_howto  
                CVS            
                ..
            ..
            images         
                CVS            
                ..
                callouts       
                    CVS            
                    ..
                ..
            ..
            lession_scm    
                CVS            
                ..
            ..
            nightlybuild   
                CVS            
                ..
            ..
            pgp            
                CVS            
                ..
                images         
                    CVS            
                    ..
                ..
            ..
            pm_fw_diary_2_4
                CVS            
                ..
            ..
            pm_fw_module_debug
                CVS            
                ..
            ..
            pm_fw_plan_2_4 
                CVS            
                ..
            ..
            program_rules  
                CVS            
                ..
            ..
            rd_hwenv       
                CVS            
                ..
            ..
            steam_admin    
                CVS            
                ..
            ..
            steam_howto    
                CVS            
                ..
                images         
                    CVS            
                    ..
                ..
            ..
            steam_trans    
                CVS            
                ..
            ..
            tip_sysconfig  
                CVS            
                ..
            ..
            tip_sysinstall 
                CVS            
                ..
                images         
                    CVS            
                    ..
                ..
            ..
        ..
        html           
            CVS            
            ..
            resources      
                CVS            
                ..
            ..
        ..
        images         
            CVS            
            ..
            gif            
                CVS            
                ..
            ..
            png            
                CVS            
                ..
            ..
            xpi            
                CVS            
                ..
            ..
            xpm            
                CVS            
                ..
            ..
        ..
        resource       
            CVS            
            ..
            html           
                CVS            
                ..
            ..
            ipaddr         
                CVS            
                ..
            ..
            mailaddr       
                CVS            
                ..
            ..
            pgpkey         
                CVS            
                ..
            ..
        ..
        utility        
            CVS            
            ..
            ltutil         
                CVS            
                ..
            ..
        ..
    ..
..
</screen>
</sect2>
<sect2><title>Starteam 中的文件和目录的共享</title>
<para>
Starteam 可以在同一 ServerConfiguration 中共享数据，既可以在不同视图，
亦可在不同的工程中共享。在图形界面下操作简洁。
</para>
<para>
但命令行不具有相应功能。
</para>
</sect2>
</sect1>


<sect1 id="steam-howto"><title>Starteam Howto</title>
<para>
针对 STARTEAM，写了如下 HOWTO。原因是图形界面的操作固然尤其方便性，但也随处埋藏着地雷。
</para>
<para>
例如：权限设置不当，任何人可以选择工程的根目录，按一下DEL键，只有一次确认机会，便会在不到一秒种的时间，删除整个工程所有文件。如果这时不知所措，重新再次重建整个工程，比如重新 checkin 整个工程的 5,000 个文件，则服务器中的文件个数翻倍。这些文件作为新文件，不但你为找不回Commit LOG 而头大，管理员总有一天为服务器存储空间头大。
</para>
<sect2 id="serverconfig"><title>Server Configuration</title>
<sect3>
<title>用户角度</title>
<para>
在使用 starteam 客户端连接服务器前，首先要设置服务器的IP地址，端口号等参数，以建立连接starteam服务器的Profile。这可以称为用户眼中的Server 
Configuration。
</para>
<para>
用图形界面的 starteam 客户端，如下方式设置：
</para>
<orderedlist>
<listitem>
<para>
Project-->Open-->Add Server
</para>
</listitem>
<listitem>
<para>
设置服务器名，IP地址，协议（TCP/IP Sockets），端口（49201），加密（选择任意一种加密方式）。
</para>
</listitem>
</orderedlist>
<para>
命令行 starteam ，请用我们自己封装的 Wrapper: "st" 。
</para>
<screen>
obsd99:/home/jiangxin/work/src/project/main>st config
StarTeam Configuration
Original starteam server is 10.1.1.60
new server:[10.1.1.60]
Original starteam server port is 49201
new server port:[49201]
original username is jiangxin
new username:[jiangxin]
Password:[********]
Original checkout project is project
Project you want to checkout:[project]
Original checkout view is  ("/" means root view)
View you want to checkout:[]
Original checkout folder is Development ("/" means root folder)
Folder you want to checkout:[Development]
Working dir is /usr/home/jiangxin/work/src/project/main
Your working directory:[/usr/home/jiangxin/work/src/project/main]
Sticky tag base on date :  ("/" means not exist)
Date:[]
Sticky tag base on label :  ("/" means not exist)
Label:[]
Sticky tag base on promotion-state :  ("/" means not exist)
Promotion-state:[]

</screen>
<para>
Server Configuration的配置保存在工作目录中；用户口令加密保存在用户主目录的文件 .stpass 中。
</para>
</sect3>
<sect3>
<title>管理员角度</title>
<orderedlist>
<listitem>
<para>一个服务器配置（Server Configuration），作为一个独立的服务运行，有独立的
用户数据库，独立的版本控制文件仓库（Repository），独立的一个数据库来支持。
</para>
</listitem>
<listitem>
<para>一台服务器上可以运行多个不同的STARTEAM服务器配置，不同的SERVER 
CONFIGURATION需要分配不同的端口设置。
</para>
</listitem>
<listitem>
<para>一个服务器配置内可以运行多个工程（PROJECT），一个Project中可以有多个视图
（View），视图中有目录、文件、Change Request等元素组成。
</para>
</listitem>
<listitem>
<para>一个服务器配置中的文件等元素可以在工程之间，视图之间共享（类似于拷贝的动
作）；但是元素不能跨服务器配置共享。
</para>
</listitem>
<listitem>
<para>文件结构：
</para>
<para>配置文件
</para>
<para>Configuration\server.scg</para>
<para>Configuration\server.cph</para>
</listitem>
<listitem>
<para>数据库文件
</para>
<para>Database\StarTeamDB.mdb (Assuming Access database)
</para>
</listitem>
<listitem>
<para>数据仓库
</para>
<para>版本控制文件仓库（Repository）：Vault/Archive/ ；
版本控制文件存储在该目录中，其中没有子目录，文件名以流水号依次排列；
每个文件控制一个分支的所有版本文件的控制，类似于CVS的版本控制文件，但不同之
处是该文件包含二进制的头尾，如果文件分支，CVS仍由一个文件来控制，而STARTEAM
则形成一个新的文件；CVS的TAG包含在文件上，即如果对文件加TAG，文件被更新，而
STARTEAM的LABEL（相当于CVS的TAG）不包含在文件中，而是存储在数据库中。
</para>
</listitem>

<listitem>
<para>
Cache
</para>
<para>Cache文件夹是为了加速文件CHECKOUT。当一个文件被CHECKOUT，便在该目录建立
Cache，文件名结构为："文件名.版本号"。
</para>
</listitem>
<listitem>
<para>其他
</para>
<para>包括LOG，Attachments（change request, Topic等的附件文件）
</para>
</listitem>
</orderedlist>
</sect3>
</sect2>

<sect2 id="project"><title>Project</title>
<sect3>
<title>用户角度</title>
<para>
选择Server Configuration 列表，输入正确的用户名和密码，即打开该 Server
Configuration 下你有权限的工程列表，选择某一工程。
</para>
</sect3>

<sect3>
<title>管理员角度</title>
<orderedlist>
<listitem>
<para>
在 Server Configuration 下，列表显示的工程列表，即代表了一个个工程。
</para>
</listitem>
<listitem>
<para>
工程是由一系列视图组成，根视图通常作为工程的缺省视图，直接选择某工程，和选择
缺省视图的效果一致；
</para>
<para>
创建工程，即创建工程的根视图。尽量在设置权限时，按照工程、视图、文件夹的方式
来设置权限。
</para>
</listitem>
<listitem>
<para>
设置权限时，一定设置工程和视图不能被任何人删除！因为一旦删除无法找回。
</para>
</listitem>
</orderedlist>
</sect3>

</sect2>

<sect2 id="view"><title>View</title>
<orderedlist>
<listitem>
<para>
通过 Project-->Open 来打开某一工程，会显示视图列表。视图间的关系通过一个树图
表示出来。根视图通常作为工程的缺省视图，直接选择某工程，和选择缺省视图的效果
一致；
</para>
</listitem>
<listitem>
<para>
根视图通常表示目前正在开发的版本；而分支视图表示维护的旧代码分支，或者功能独立
的代码分支；
</para>
</listitem>
<listitem>
<para>视图是主要用途是管理分支，即将一个分支作为一个独立的视图；当然也可以对
不同用户建立视图，但是通过对目录的权限控制来实现不同用户使用同一个视图更好；
</para>
</listitem>
<listitem>
<para>
如果对视图中不同目录分别设置权限，则用户查看该视图，只能看到具有权限的目录。
</para>
</listitem>
<listitem>
<para>
label只在同一个视图中起作用，且View Label, Build Label, Promotion State
作用于一个视图中所有文件；
</para>
</listitem>
<listitem>
<para>由于Change Request需要用到Build Label，测试人员用到Promotion State，
因此需要在同一个视图内存放程序目录，Change Request目录，测试人员目录等；但
文档具有相对独立性，建议单独建立工程，再共享到其他工程和视图中。
</para>
</listitem>
</orderedlist>
</sect2>

<sect2 id="branch"><title>Branch</title>
<sect3><title>STARTEAM和CVS的分支不同点</title>
<orderedlist>
<listitem>
<para>
CVS基于文件管理，不同分支的同一文件，即使内容不同，也都体现在同一个文件中；
STARTEAM 建立分支是基于工程和数据库，两个分支的文件可以指到一个相同的物理文件，
也可以使不同的物理文件，这样两个分支的文件可以同步变化（float branch），
也可以分别独立控制（fixed branch）；
</para>
</listitem>
<listitem>
<para>
CVS分支用tag来管理，不同分支用 rtag/tag -b 来建立，并且不同分支打的
分支tag或tag，可以被其他分支看到。
STARTEAM 的分支不通过建立标签实现，而是生成另外的一套数据库。
</para>
</listitem>
<listitem>
<para>
STARTEAM建立分支的方式：
<itemizedlist>
<listitem>
<para>
同一视图的不同目录
</para>
<para>
另外建立一个目录作为分支的根目录，用ctrl+Drag将预建立分支的版本在
该目录建立共享，再选择BehavioràBranch on change；则在这些文件修改并checkin
时，会建立新文件而分支；也可以为方法1新创建的分支目录来建立视图来方便管理。
</para>
</listitem>
<listitem>
<para>
不同的视图（建立分支视图）
</para>
<para>
创建分支视图，在创建过程中选择Permit items to branch within this view，
来创建分支。分支视图的好处是，有自己独立的lable(tag)命名空间，不象CVS
只有一个TAG命名空间。
</para>
</listitem>
<listitem>
<para>
推荐使用分支视图方式。
</para>
</listitem>
</itemizedlist>
</para>
</listitem>
<listitem>
<para>
CVS、STARTEAM都可以实现分支和主线和合并。
</para>
<para>
CVS 命令行功能强大，可以通过命令行完成分支的管理；而 starteam 
对视图的管理只能通过图形界面实现。
</para>
</listitem>
</orderedlist>
</sect3>
<sect3><title>建立分支注意事项</title>
<sect4><title>通过分支视图建立</title>
<itemizedlist>
<listitem>
<para>
建立新视图，在步骤一，选择文件分支，如图
</para>
<para>
<mediaobject><imageobject>
<imagedata fileref="images/st_branch_a1.jpg" format="JPEG"/>
</imageobject>
<textobject>
<phrase>建立分支视图步骤一</phrase>
</textobject>
<caption>
<para>建立分支视图步骤一
</para>
</caption>
</mediaobject>
</para>
</listitem>
<listitem>
<para>
在步骤五，注意"Floating Configuration"和"Configure as ..."的区别
</para>
<para>
<mediaobject>
<imageobject>
<imagedata fileref="images/st_branch_a5.jpg" format="JPEG"/>
</imageobject>
<textobject>
<phrase>建立分支视图步骤五</phrase>
</textobject>
<caption>
<para>建立分支视图步骤五
</para>
</caption>
</mediaobject>
</para>
<para>
一般情况下，请选择"Configure as ..."，这样当建立完成后，程序即刻分支，否则
选择"Floating Configuration"，子视图在没做修改前，一直和父视图同步，称为
"Variant View"。
</para>
<para>
如果选择了"Floating Configuration"，可以通过将分支视图的所有文件强制
 Check In，即可。
</para>
</listitem>
<listitem>
<para>
判断建立好的视图是否为分支视图，查看视图的属性。
</para>
<para>
<mediaobject>
<imageobject>
<imagedata fileref="images/st_branch_a6.jpg" format="JPEG"/>
</imageobject>
<textobject>
<phrase>视图的属性</phrase>
</textobject>
<caption>
<para>视图的属性
</para>
</caption>
</mediaobject>
</para>
</listitem>
</itemizedlist>
</sect4>

<sect4><title>通过文件共享建立分支</title>
<para>建立一个目录作为分支的根目录，用ctrl+Drag将预建立分支的版本在该目录
建立共享，再选择Behavior->Branch on change；则在这些文件修改并checkin时，
会建立新文件而分支；
</para>
<para>通过该方法建立的分支，分支文件仍和主干文件保持同步，直到分支的文件
被修改而不是主干文件修改，方建立分支。
</para>
<para>如果想从一开始便建立分支，将分支文件强制 Check In，即可。
</para>
</sect4>

</sect3>
</sect2>

<sect2 id="label"><title>Label</title>
<para>
STARTEAM的标签（LABEL）主要用来记录事件，如里程碑，和代码分支没有
必然的联系；而 CVS 的分支必须依靠 TAG 来完成。
</para>
<para>
CVS 的TAG是记录在文件中，建立 tag ，耗时；Starteam 的 LABEL是建立在
数据库基础上的，建立 label，属于毫秒及的动作。
</para>
<para>
Starteam 地 LABEL 是建立在视图中，文件和视图脱离关系，该文件上的 label
失去。
</para>
<para>
如何使用LABEL管理项目的示例，参见：<ulink url=
"http://www.fox.se/english/starteam/best_practices/
starteam_best_practices.htm">
http://www.fox.se/english/starteam/best_practices/starteam_best_practices.htm
</ulink>，提供了STARTEAM利用LABEL协同工作的范例，这些工作有些是CVS很难做到的。
</para>
<para>
下面具体介绍 label 的几个不同的变种： View Label, Build Label, Promotion State,
Revision Label。
</para>

<sect3><title>View Label</title>
<itemizedlist>
<listitem>
<para>View Label 针对一个View中所有文件，可以用来记录项目的里程碑。
</para>
</listitem>
<listitem>
<para>View Label非常灵活，可以将后来新增加的文件加入到View Label中。
</para>
</listitem>
<listitem>
<para>文件移到到其他视图和文件删除对view label 有不同影响：移出文件的
View Label会自动去掉，并且历史视图，该文件也不存在了，因为文件被移动了。
删除的文件则不然，仍可以通过历史被访问到，并且删除前的文件仍然具有该
View Label
</para>
</listitem>
</itemizedlist>
</sect3>


<sect3><title>Build label</title>
<itemizedlist>
<listitem>
<para>在创建View Label中有"Use as Build Label"的选项，默认创建的View Label
就是Build Label。
</para>
</listitem>
<listitem>
<para>Build Label基本上等同于View Label，除了Build Label 在Change Request的
工作流程中会被引用到。Build Label可以用来帮助测试人员了解Bug在哪一个
Build Label中被解决了。
</para>
</listitem>
</itemizedlist>
</sect3>

<sect3><title>Promotion state</title>
<itemizedlist>
<listitem>
<para>
Promotion State 可以看作是是浮动的View Label， View Label 的标签；
</para>
</listitem>
<listitem>
<para>
通常要建立的 Promotion State 有： Release, Beta Test, Alpha Test, ...。
并且要按照顺序建立，这样可以通过提升，将 Beta Test 对应的 Build Label，
提升为 Release，即用 Release 来指向 Beta Test 的Label。
</para>
</listitem>
<listitem>
<para>
建立在View Label基础之上，为编译 Checkout 代码，提供一个一致的Label。
可以方便地建立 Nightly Build 系统。
</para>
</listitem>
</itemizedlist>
</sect3>

<sect3><title>Revision label</title>
<itemizedlist>
<listitem>
<para>
Revision label可以用来对一个视图中单独的文件或某些文件
（或元素如change request），单独建立label。便于文件查找。
</para>
</listitem>
<listitem>
<para>
同View Label一样，文件如果被移动到该视图之外，失去Revision Label。
</para>
</listitem>
</itemizedlist>
</sect3>

</sect2>

<sect2 id="directory"><title>目录划分</title>
<table frame='all'><title>项目工程目录结构</title>
<tgroup cols='3' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry align="center">目录</entry>
  <entry align="center">说明</entry>
  <entry align="center">权限</entry>
</row>
</thead>
<tbody>
<row>
  <entry>Development</entry>
  <entry>程序源码，及帮助</entry>
  <entry>组成员完全权限</entry>
</row>
<row>
  <entry>Defect</entry>
  <entry>用于记录缺陷控制的目录</entry>
  <entry>组成员控制changRequest完全权限；所有人具有添加修改changeRequest权限
  </entry>
</row>
<row>
  <entry>Document</entry>
  <entry>项目文档</entry>
  <entry>组成员完全权限；文档工程师完全权限。（现已废弃不用）</entry>
</row>
<row>
  <entry>ProjectManagement</entry>
  <entry>项目范围控制，时间控制等</entry>
  <entry>组成员读权限；项目经理完全权限</entry>
</row>
</tbody>
</tgroup>
</table>
<warning>
<para>以上各个目录，只有项目管理人员和系统管理员具有修改安全设置权限。
</para>
</warning>

<sect3><title>源码的版本控制</title>
<itemizedlist>
<listitem>
<para>Development目录下建立各个相关模块目录；
</para>
</listitem>
<listitem>
<para>模块的目录组织结构应该和 checkout 到本地的编译代码目录结构一致。
</para>
</listitem>
<listitem>
<para>
注意二进制文件尽量不要放在 Starteam 中，而改用其它方式（如文件服务器），
来进行存储！
</para>
</listitem>
</itemizedlist>
<para>
<mediaobject>
<imageobject>
<imagedata fileref="images/st_layout.jpg" format="JPEG"/>
</imageobject>
<textobject>
<phrase>CWAP 1.1分支视图目录结构图</phrase>
</textobject>
<caption>
<para>CWAP 1.1分支视图目录结构图
</para>
</caption>
</mediaobject>
</para>
</sect3>

<sect3><title>文档的版本控制</title>
<para>
文档的管理，涉及到大量的二进制文档（WORD），改用文件服务器来存储。
</para>
</sect3>

<sect3><title>缺陷控制</title>
<itemizedlist>
<listitem>
<para>建立 Defect 目录，并在其下建立需要测试的相应模块的目录。
</para>
</listitem>
<listitem>
<para>目录的权限设置为只读（对QA经理开放建立目录权限等）。
对于change request，设置为任何人/QA/组内人员具有添加，修改权限等。
</para>
</listitem>
<listitem>
<para>
建立Defect Tracing目录，而不是在根目录下存放change request的好处是:
1. 便于设置权限；2. 建立相应模块，便于bug归类存放，不用在category中填写
易出错。
</para>
</listitem>
</itemizedlist>
<para>
<mediaobject>
<imageobject>
<imagedata fileref="images/st_defect.jpg" format="JPEG"/>
</imageobject>
<textobject>
<phrase>Defect 示例</phrase>
</textobject>
<caption>
<para>Defect 示例
</para>
</caption>
</mediaobject>
</para>
</sect3>

<sect3><title>ProjectManagement目录</title>
<para>
ProjectManagement 下，通过文件和topic方式，存储TODO LIST, 
编程规范，需求变更等信息。用户进行范围管理，工作管理等。
</para>
<para>
ProjectManagement 权限设置为项目经理完全权限。
</para>
</sect3>
</sect2>

<sect2 id="delundel"><title>删除和反删除</title>
<para>
删除和反删除文件是 Starteam 和 CVS 最大的不同点之一。如果处理不好，虽然
不会造成信息丢失，但处理方式不擅，将给 starteam 服务器端引入过多的数字
垃圾。
</para>
<para>
原则是：
</para>
<itemizedlist>
<listitem>
<para>
添加文件慎重
</para>
<para>
添加文件前，一定要将临时文件和二进制文件（编译过程的目标文件，可执行文件等）
排除在外，以免引入数据垃圾。因为 Starteam 很难将文件彻底从服务器端删除。
</para>
</listitem>
<listitem>
<para>
反删除文件照章办事
</para>
<para>
反删除文件，按照本文档的步骤执行。严禁通过重新添加方式，反删除，否则同样引入
数据垃圾！
</para>
</listitem>
</itemizedlist>

<sect3><title>Starteam文件存放机理</title>
<para>
STARTEAM以数据库为核心，是面向工程的管理方式。版本控制文件的文件名
由数据库管理，文件名不过是"指针"。方便文件在一个工程甚至同一个
Server Configuration的不同工程中的共享，以及任意移动和组织。
</para>
<para>CVS,Perforce以文件为核心，即面向文件的管理方式，文件可以方便的重新
组合以及移植。原子化的Check In、二进制文件的版本控制是更Perforce的优势。
但是缺点是很难完成一个工程中，文件的移动及文件改名给前后不同版本/分支带来
问题；不当处理或者丢掉以前版本控制中的文件部署，或者增加由于文件冗余增加
占用空间。
</para>
<para>STARTEAM的不利因素是很难将一个工程或者Server Configure中的文件分离、
组合、单独移植。其数据仓库 Repository像一个黑盒子，所有Project的所有版本
控制文件，都放在同一个目录下（Vault/Archive目录下，这是starteam的不足）。
目前缺乏良好的文件管理工具，是一个缺憾。
</para>
<para>
Starteam 一旦对文件进行版本控制，就丢入 Repository 目录中，很难在从中删除。
这应当看作是其最大的 BUG。
</para>
</sect3>

<sect3><title>删除</title>
<para>
无论文件从哪个视图（根view，子view）添加目录和文件到starteam，在
该view下显示的文件夹和文件只不过是Vault/Archive目录下文件（以流水号作为
文件名），在数据库（starteam的管理核心）中的一个"指针"，删除文件，不过是
删除了"指针"，虽然没有真正删除文件，但是如果数据库中的所有关于某个文件的
"指针"都删除，文件只能通过历史来查看。但可以通过适当方法，通过历史的
"指针"重新找回版本控制。
</para>
</sect3>

<sect3><title>移动</title>
<para>
文件在同一个视图中移动时，历史被保留；但当文件在不同视图中移动（注意不是删除）
时，原视图即使在历史中也找不到该文件，该文件从该视图中彻底消失了。如果将
一个视图彻底删除，如果该视图下文件没有在其他视图中建立共享的话，则造成文件
丢失，无法找回。
</para>
<para>为防止此类事故的发生，经常备份，并设置任何人都没有工程和视图的删除
权限。
</para>
<para>
</para>
</sect3>

<sect3><title>反删除的步骤</title>
<orderedlist>
<listitem>
<para>同时打开当前视图和删除文件之前的视图，拷贝历史视图的文件到当前视图。
</para>
<mediaobject>
  <imageobject>
    <imagedata fileref="images/st_undel1.jpg" format="JPEG"/>
  </imageobject>
  <textobject>
    <phrase>image</phrase>
  </textobject>
  <caption>
   <para>
</para>
  </caption>
</mediaobject>
</listitem>

<listitem>
<para>设置新视图中历史文件的属性。
</para>
<mediaobject>
  <imageobject>
    <imagedata fileref="images/st_undel2.jpg" format="JPEG"/>
  </imageobject>
  <textobject>
    <phrase>image</phrase>
  </textobject>
  <caption>
   <para>
</para>
  </caption>
</mediaobject>
</listitem>

<listitem>
<para>设置新视图中历史文件的属性。由历史reversion的只读版本修改成为
 Floating 版本即可。
</para>
<mediaobject>
  <imageobject>
    <imagedata fileref="images/st_undel3.jpg" format="JPEG"/>
  </imageobject>
  <textobject>
    <phrase>image</phrase>
  </textobject>
  <caption>
   <para>
</para>
  </caption>
</mediaobject>
</listitem>
</orderedlist>
<para>
</para>
<para>
</para>
</sect3>
</sect2>

<sect2 id="defect"><title>文件服务器和个人版本控制</title>
<para>starteam的使用，并不能取代现有文件服务器的功能，因为starteam的版本控制
系统文件存储的特殊性。
</para>
<para>starteam所有版本控制文件存贮在同一个目录下（Vault/Archive），没有任何
子目录，文件名按照流水号递增，并且一个文件一旦进入版本控制，一直不会删除。
</para>
<para>优点是可以方便文件的改名，重新的目录组织，而不是象CVS那样很难修改文件名。
</para>
<para>缺点是无法控制文件存储方式和存储量，对二进制（包括WORD文档）的版本控制
管理不好。因此一些工具及不需要版本控制的文件尽量仍放在文件服务器上。
</para>
<para>starteam不是百宝箱，但更不能成为垃圾桶。如对一些不需要纳入工程，统一
管理的，但仍需要版本控制的文件，建议使用CVS，进行个人维护。CVS有Unix和NT版本
的SERVER，都很好用。
</para>
</sect2>

<sect2 id="workstation"><title>客户端设置</title>
<itemizedlist>
<listitem>
<para>
换行符转换（CRLF-&gt;LF）
</para>
<para>
选择根目录或者需要单独设置的目录，选择菜单：
<menuchoice>
  <guimenu>Folder</guimenu>
  <guimenuitem>Properties</guimenuitem>
  <guimenuitem>Files</guimenuitem>
  <guimenuitem>Eol Conversion</guimenuitem>
</menuchoice>，如图：
</para>
<para>
<mediaobject><imageobject>
<imagedata fileref="images/st_wrkcrlf.jpg" format="JPEG"/>
</imageobject></mediaobject>
</para>
</listitem>
<listitem>
<para>
Workstation Options
</para>
<para>
选择
<menuchoice>
  <guimenu>Tools</guimenu>
  <guimenuitem>Workstation Options</guimenuitem>
</menuchoice>
</para>
</listitem>
<listitem>
<para>
Workstation Options: Workspace
</para>
<mediaobject><imageobject>
<imagedata fileref="images/st_wrk1.jpg" format="JPEG"/>
</imageobject></mediaobject>
<orderedlist>
<listitem>
<para>
在目录和Change Request中切换过程中，不改变文件夹
</para>
</listitem>
<listitem>
<para>
改变路径时，取消文件递归，避免打开文件递归，切换到文件较多的目录，影响响应速度
</para>
</listitem>
<listitem>
<para>
切换文件夹，保持对filter的修改
</para>
</listitem>
<listitem>
<para>
对多用户环境（如管理员）有帮助
</para>
</listitem>
</orderedlist>
</listitem>

<listitem>
<para>
Workstation Options: Files
</para>
<mediaobject><imageobject>
<imagedata fileref="images/st_wrk2.jpg" format="JPEG"/>
</imageobject></mediaobject>
<orderedlist>
<listitem>
<para>
将文件的最后修改时间作为检出时间（强力推荐），否则为当前时间
</para>
</listitem>
<listitem>
<para>
只在必要时，打开Merge程序解决冲突
</para>
</listitem>
<listitem>
<para>
设置默认文字处理程序，如: Ultraedit
</para>
</listitem>
<listitem>
<anchor id="faq-slowconn"/>
<para>
吴昭坚报告说：“如果把 Optimize for slow connection 的勾给选上了，结果在check out文件时极慢（check 一个文件要差不多1分钟）”
</para>
<para>
如果网络速度足够快，就把这个钩钩去掉，以减轻服务器和客户端的计算负担。吴昭坚还报告说 st 命令行亦会变慢，我觉得 st 变慢，
是由于 ip 反向解析造成的超时，可以在 hosts 中加上 starteam 服务器的相关地址映射（如： 10.0.0.60  starteam），更极端的做法是
删除 /etc/resolv.conf。
</para>
</listitem>
</orderedlist>
</listitem>
<listitem>
<para>
修改口令和个人信息
</para>
<para>
选择
<menuchoice>
  <guimenu>Tools</guimenu>
  <guimenuitem>Server Administration</guimenuitem>
  <guimenuitem>My Account</guimenuitem>
</menuchoice>
</para>
</listitem>
</itemizedlist>
</sect2>

<sect2 id="built"><title>Nightly Build和测试</title>
<para>
参见《自动编译系统（Nightly Build）》
</para>
</sect2>

<sect2 id="starteam-cli"><title>Starteam CLI Wrapper</title>
<para>
stcmd 是 starteam 的命令行工具，基于 java。因此运行 stcmd，首先需要建立
java 环境。对于 OpenBSD 系统，要Enable FreeBSD Compatible，再安装 Jave
虚拟机。
</para>
<para>
Starteam 的功能远远弱于其图形界面，而且命令行参数复杂，难于使用。我们
用 SHELL 包装了一层：“st”，采用类似 CVS 的命令行。
</para>
<para>
理解 .starteam.ini
</para>
<screen>
# .starteam.ini 通过命令 st config 生成
# StarTeam Configuration: /usr/project/branch2/release/.starteam.ini
STUSER="releng"
STPASSWDFILE="/project/.relfw.passwd"
STSERVER="10.1.1.60"
STPORT="49201"
STWORKROOT="/usr/project/branch2/release"
STPROJECT="project"
STVIEW="branch_2_0"
STFOLDER=""
STCFGD=""
STCFGL=""
STCFGP="release"
</screen>

<para>
st 的参数及使用方法
</para>
<screen>
StarTeam command line emulator, $Revision: 1.60 $, by YZW,JX

Usage: st [st_options] [st_command] [command_options] [command_args]
    st      
            The name of the starteam wrapper
    st_options
            Some options that affect all sub-command of st.
    st_command
            One of several different sub-commands.
    command_options
            Options that are specific for the command.
    command_args
            Arguments to the commands.
    
    Global options
    =============================================
    -h      help
    -V      show version
    -r      readonly
    -w      readwrite
    -v      verbose, show version info. (--nv : no verbose)
    -z      compress during tranfer. (--nz : not compress)
    -q      a bit quiet mode. only show difference.
    -qq     more  quiet mode. more quiet then -q. 
            (not show status "Not In View" and folder info)
    -Q      most  quiet mode. output nothing. 
            (--nq: not quiet is default)
    --eol    set eol(symbol of end-of-line) to platform specific. 
            CR on unix, CR/LF on windows. (--neol : leave eol aside)
    -I      Interactive mode. (    --nI / --batch : Batch mode.)
    -S / -s    
            Stop on error./ No Stop.
    --exitcode
            On Error return 1, success return 0. 
            Conflict with -q and -qq
    
    Command Options
    =============================================
    -f      Force. Force starteam to ci/co a new revision even if you 
            haven't made any changes to the file. _'
    -l      Local; run only in current working directory, rather than 
            recursing through subdirectories.
    -R      Process directories recursively.
    -m message
            Use message as log information, instead of invoking an editor.
    -D date spec
            Use the most recent revision no later than date spec. 
            date spec is a single argument, a date description specifying 
            a date in the past.
    --lock / --unlock
            Lock files./Unlock files.
    -r tag
            Use the revision specified by the tag argument instead of the
            default head revision.
    
    Commands
    =============================================
    
    help
    ----------------------------------------
    Syntax:    st help
        Show this screen.

    config
    ----------------------------------------
    Syntax:    st config
        Maybe the first command you run. Configure INI file.

        Truth behind "st config". Only for smart boys/girls:
            After running this configuration, a config file, .starteam.ini
            will be created under current directory.
            There several KeyValue pairs.

                STUSER  :       login name for starteam user
                STSERVER:       ip address of starteam server
                STPORT  :       tcp port of starteam server
                STPROJECT:      project name you want to check in/out
                STVIEW  :       view    name you want to check in/out
                STFOLDER:       folder name of the view you want to check
                STCFGD  :       check out base on Date.
                                Date format:
                                        "12/29/97 10:52 AM"
                                        "29-Dec-97 10:52:00 AM"
                                        "December 29, 1997 10:52:00 AM PST"
                                        "Monday, December 29, 1997 10:52:00 
                                                oclock AM PST"
                STCFGL  :       check out base on Label
                STCFGP  :       check out base on Promotion State
                STWORKROOT:     the root of your working dir
                


    default
    ----------------------------------------
    Syntax:    st default
        Show default params

    add
    ----------------------------------------
    Syntax:    st [global_opts] add [--lock|--unlock|--nelock] [-m "message"] 
                [--vl "label"] [files...]
        Add files to version control

    import    (add-folder)
    ----------------------------------------
    Syntax:    st [global_opts] import [--ex "excludeType"][--exlist "fileMask" |
                 --exfile "fileName"] [foldername...]
        Add directory.

    ci    (commit / checkin)
    ----------------------------------------
    Syntax:    st [global_opts] ci [--filter ...] [--lock|--unlock] [-m "comment"]
                [--force] [--necessary] &lt;files...&gt;
        Check in files from local to server.

    co    (checkout / update / up)
    ----------------------------------------
    Syntax:    st [global_opts] co [--lock|--unlock] [-r revision] [--nessary] 
                [--touch][--merge [--dryrun|--alwaysprompt|--neverprompt|
                --conflictprompt] &lt;files...&gt;
        Check out files from server to local.

    checkdir (cd)
    ----------------------------------------
    Syntax:    st [global_opts] cd &lt;directory...&gt;
        Check out the Directory structure, but no files.

    diff
    ----------------------------------------
    Syntax:    st [global_opts] diff [-r revision] [--filter ...] &lt;files...&gt;
        differ.

    list
    ----------------------------------------
    Syntax:    st list &lt;files...&gt;
        List files. Show file size and status.

    log    (history)
    ----------------------------------------
    Syntax:    st [global_opts] diff [-r revision] [--filter ...] &lt;files...&gt;
        Show logs.

    status
    ----------------------------------------
    Syntax:    st status
        Update file status.

    tag    (lable / apply-label)
    ----------------------------------------
    Syntax:    st [global_opts] tag [--filter "fileStatus"] 
                [--vl "labelName"|--vd "asOfDate"|--vn revision]
                --label "labelName" [files...]
        Apply a already exist lable to file(s).

    describe (dsc)
    ----------------------------------------
    Syntax:    st dsc -m "message" &lt;files&gt;
        Change the desciption of file(s).

    release    (remove /rm)
    ----------------------------------------
    Syntax:    st [global_opts] rm [--filter ...] &lt;files...&gt;
        Remove Local files.

    remove-repos (rm-repos)
    ----------------------------------------
    Syntax:    st [global_opts] rm-repos [--filter ...] &lt;files...&gt;
        Remove files from version control.

    undelete
    ----------------------------------------
    Syntax:    st undelete
        Only be can be done in GUI mode.

    lock
    ----------------------------------------
    Syntax:    st lock 
        Lock and Unlock files.

    mk-build-label
    ----------------------------------------
    Syntax:    st mk-build-label
        Make a build label.

    mk-revision-label
    ----------------------------------------
    Syntax:    st mk-revision-label
        Make a revision label.

    mk-view-label
    ----------------------------------------
    Syntax:    st mk-view-label
        Make a view label.

    admin
    ----------------------------------------
    Syntax:    st admin --server &lt;server&gt; --pwdfile &lt;pwdfile&gt; [lock|unlock]
        Server admistration command. Lock/Unlock server.


    update this script and other scripts:
        st getst
        st putst

    Filters:
        C: Current
        G: Merge
        I: Missing
        M: Modified
        N: Not in view
        O: Out Of Date
        U: Unknown
"st getst" : Update your st immediately.

</screen>
</sect2>

<sect2 id="integration"><title>StarTeam 与 常用开发工具整合</title>
<para>
StarTeam 可以和如下开发工具整合
</para>
<itemizedlist>
<listitem>
<para>
Starbase CaliberRM 4.0 
</para>
</listitem>
<listitem>
<para>
Starbase CodeWright 7.0 
</para>
</listitem>
<listitem>
<para>
Microsoft Visual Studio .NET (Visual Basic, C++ and C# projects) 
</para>
</listitem>
<listitem>
<para>
Microsoft Visual C++ 6.0 
</para>
</listitem>
<listitem>
<para>
Microsoft Visual Basic 6.0 
</para>
</listitem>
<listitem>
<para>
IBM WebSphere Studio Workbench 4.0.0 and 4.0.3 
</para>
</listitem>
<listitem>
<para>
Sybase PowerBuilder 7.0 and 8.0 
</para>
</listitem>
<listitem>
<para>
Rational Rose 2001 and 2002 
</para>
</listitem>
<listitem>
<para>
Embarcadero Describe 5.5 and 5.8 
</para>
</listitem>
<listitem>
<para>
Microsoft Access 2000 and 2002 
</para>
</listitem>
<listitem>
<para>
Borland JBuilder 6.0 and 7 
</para>
</listitem>
<listitem>
<para>
Borland Delphi 5.0 and 6.0 
</para>
</listitem>
<listitem>
<para>
Borland C++Builder 5 and 6 
</para>
</listitem>
<listitem>
<para>
Microsoft Visual InterDev 6.0 
</para>
</listitem>
<listitem>
<para>
Oracle Developer 2000 and 6 
</para>
</listitem>
<listitem>
<para>
Microsoft Project 98, 2000 and 2002
</para>
</listitem>
</itemizedlist>

<para>
Starteam 和这些开发工具的整合需要安装 “StarTeam Integration”，
如对于和 Microsoft Visual C++ 整合，需要安装
“StarTeam Microsoft SCC Integration”。
</para>
<para>
下载 <ulink url="http://www.starbase.com/product_starteam/integrations/downloadopenintegrations.cfm">
StarTeam Integration</ulink>。
</para>

</sect2>
</sect1>


<sect1 id="starteam2cvs"><title>版本管理工具迁移</title>
<para>
更换版本控制工具一定是万不得已而为之。处理不当，将会丢失文件的版本历史记录，这无异于一场灾难。下面仅仅讨论了从 Starteam 移植到 CVS 的过程，其它类型的迁移可以举一反三。
</para>

<sect2><title>用同一套本地目录，对应于相应的 STARTEAM 和 CVS 工程</title>
<para>
导出工程在 Starteam 中的文件和目录结构，并在 CVS 中创建新的工程“project”，并导入目录结构。
</para>
<screen>
# <command>cd ~jiangxin/work/</command>
# <command>mkdir project</command>
# <command>cd project</command>
# <command>st config </command>
配置为 Starteam 的 project 工程视图
# <command>st cd </command>
# <command>cvs import -m "create directory" project Johnson init</command>
##该命令等效于：
# <command>for i in `find . -type d -exclude "CVS"`; do cvs add $i; done</command>
</screen>
</sect2>

<sect2><title>导出 Starteam 每个文件的Commit Log</title>
<para>
从 Starteam 中 Checkout 出每个文件，在将每个文件的Commit Log 导出为扩展名为 .jxlog 的文件。
导出的 log 被应用程序 steam2cvs 分析并生成脚本，用于完成文件从 starteam 向 cvs 迁移。
</para>
<screen>
# <command>cd ~jiangxin/work/project</command>
# <command>st -qq co</command>
# <command>for i in `find . -type f -exclude "CVS"`; do i=${i#./}; st log $i >$i.jxlog; done</command>
</screen>
<para>
复杂一些的脚本：
</para>
<screen>
<![CDATA[
#!/bin/sh

cd <PATH>

xxx=0

for i in `find . -type f`; do 
        if  echo $i | grep -w -e "CVS" -e ".jxlog" -e ".jxsh"; then
                continue
        fi 

        j=${i}.jxlog
        if [ -f $j ]; then
                continue
        fi
        i=${i#./}
        st log $i >$i.jxlog.tmp
        mv -f $i.jxlog.tmp $i.jxlog
        xxx=`eval "expr $xxx + 1"`
        echo "$xxx : $i"
done
]]>
</screen>

</sect2>

<sect2><title>剖析STARTEAM日志，生成脚本</title>
<para>
根据每个文件的Commit Log 文件（*.jxlog），生成相应的脚本文件。
</para>
<para>
STARTEAM 日志格式如下：
</para>
<screen>
<![CDATA[
Folder: starteam  (working dir: /home/jiangxin/src/starteam)
History for: st
Description:
Locked by:
Status: Current
----------------------------
Revision: 58 View: compiler Branch Revision: 1.57
Author: nobody_used_for_utility_coci Date: 3/7/03 11:15:03 AM CST
use trap 'rm -f xxxx' EXIT to remove temporary passwd file


----------------------------
Revision: 57 View: compiler Branch Revision: 1.56
Author: nobody_used_for_utility_coci Date: 10/23/02 7:24:38 PM CST
change server ip from 60 to 6


----------------------------
...
...
...
----------------------------
Revision: 2 View: compiler Branch Revision: 1.1
Author: jiangxin(root) Date: 3/10/02 2:12:24 AM CST
jiangxin edition

----------------------------
Revision: 1 View: compiler Branch Revision: 1.0
Author: jiangxin(root) Date: 3/10/02 2:10:17 AM CST
starteam wrapper. by yangzw

=============================================================================
]]>
</screen>
<para>
通过程序 steam2cvs 转换之后的脚本示例如下：
</para>
<screen>
<![CDATA[
st -qq co -lf -r 1 st
cvs add st
cvs ci -m "starteam wrapper. by yangzw (Author:jiangxin(root), Date:3/10/02 2:10:17 AM CST)" st
st -qq co -lf -r 2 st
cvs ci -m "jiangxin edition (Author:jiangxin(root), Date:3/10/02 2:12:24 AM CST)" st
st -qq co -lf -r 3 st
cvs ci -m "ci failed (Author:jiangxin, Date:3/10/02 2:16:25 AM CST)" st
st -qq co -lf -r 4 st
cvs ci -m "cvs style wrapper (Author:jiangxin, Date:3/10/02 2:23:10 AM CST)" st
...
...
...
st -qq co -lf -r 57 st
cvs ci -m "change server ip from 60 to 6 (Author:nobody_used_for_utility_coci, Date:10/23/02 7:24:38 PM CST)" st
st -qq co -lf -r 58 st
cvs ci -m "use trap 'rm -f xxxx' EXIT to remove temporary passwd file (Author:nobody_used_for_utility_coci, Date:3/7/03 11:15:03 AM CST)" st
]]>
</screen>

<para>
转换程序 steam2cvs 即完成了上述日志到脚本的转换。源程序参见：
</para>
<para>
<ulink url="src/starteam2cvs/steam2cvs.c">steam2cvs.c</ulink>,<ulink url="src/starteam2cvs/mystring.c">mystring.c</ulink>, ...
</para>

<para>
对整个工程的文件执行此操作：
</para>
<screen>
# <command>cd ~jiangxin/work/project</command>
# <command>find . -name "*.jxlog" -o -name ".*.jxlog" -type f -exclude "CVS" -exec steam2cvs {} \;</command>
</screen>
<para>
复杂一些的脚本：
</para>
<screen>
<![CDATA[
#!/bin/sh

cd <PATH>

xxx=0

while : ; do

for i in `find . -name "*.jxlog" -o -name ".*.jxlog" -type f`; do 
        xxx=`eval "expr $xxx + 1"`
        echo -e "$xxx : proc $i ...     \c"
        steam2cvs $i
        j=${i}.jxsh
        # 运行脚本
        sh $j
        rm -f $i
        echo "done"
done

sleep 60
done

]]>
</screen>

</sect2>

<sect2><title>运行生成的脚本，完成代码 Checkin</title>
<screen>
# <command>cd ~jiangxin/work/project</command>
# <command>find . -name "*.jxsh" -o -name ".*.jxsh" -type f -exclude "CVS" -exec sh {} \;</command>
</screen>
<para>
同时在 CVS 服务器端，实时计数
</para>
<screen>
# <command>while : ; do find . -type f | wc -l ; sleep 10; done</command>
</screen>
</sect2>

<sect2><title>缺憾</title>
<para>
因为 Starteam 的Label 不能用命令行显示。因此不能自动将 Starteam 中的 LABEL 恢复为 CVS 相应的 TAG。这是一个遗憾。
</para>
<para>
对于重要的 LABEL 我们可以用手工方法重建。
</para>
</sect2>

</sect1>

<!-- CVS FAQ -->
&appendix1;

<!-- Starteam FAQ -->
&appendix2;
</article>
